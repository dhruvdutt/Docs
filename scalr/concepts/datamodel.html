<html><head><style type="text/css">@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\:form{display:block;}</style>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Appbase Documentation</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" type="text/css" href="../../bower_components/bootstrap/dist/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="../../bower_components/bootstrap/dist/css/bootstrap-theme.min.css">

  <script async="" src="http://www.google-analytics.com/analytics.js"></script><script type="text/javascript" src="../../bower_components/docbase/scripts/polyfill.js"></script>
  <!-- Flatdoc -->
  <script type="text/javascript" src="../../bower_components/jquery/dist/jquery.min.js"></script>
  <script type="text/javascript" src="../../bower_components/flatdoc/legacy.js"></script>
  <script type="text/javascript" src="../../bower_components/flatdoc/flatdoc.js"></script>

  <!-- Flatdoc theme -->
  <link rel="stylesheet" type="text/css" href="../../bower_components/flatdoc/theme-white/style.css">
  <script type="text/javascript" src="../../bower_components/docbase/scripts/flatdoc-theme.js"></script>

  <!-- DocBase -->
  <script type="text/javascript" src="../../bower_components/angular/angular.js"></script>
  <script type="text/javascript" src="../../bower_components/angular-route/angular-route.js"></script>
  <script type="text/javascript" src="../../bower_components/js-schema/js-schema.min.js"></script>

  <script type="text/javascript" src="../../bower_components/docbase/scripts/docbase.js"></script>
  <script src="../../bower_components/google-code-prettify/bin/prettify.min.js"></script>
  <link rel="stylesheet" type="text/css" href="../../bower_components/google-code-prettify/bin/prettify.min.css">
  <link rel="stylesheet" type="text/css" href="../../bower_components/docbase/styles/main.css">
  <link rel="stylesheet" type="text/css" href="../../bower_components/components-font-awesome/css/font-awesome.min.css">
  

  <!-- Custom -->
  <link rel="stylesheet" type="text/css" href="../../styles/docs.css">

</head>
<body role="flatdoc" class="no-literate big-h3 large-brief">
  <!--[if lt IE 10]>
     <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
  <![endif]-->

  <!-- ngView:  --><div ng-view="" class="ng-scope"><!-- ngInclude: 'html/navbar.html' --><nav class="navbar navbar-default navbar-fixed-top ng-scope" ng-include="'html/navbar.html'"><div class="container-fluid ng-scope">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a id="docs-appbase-logo" class="navbar-brand" href="http://docs.appbase.io">
      <img src="../../images/logo.svg">
    </a>
  </div>

  <div class="collapse navbar-collapse" id="navbar-collapse">
    <ul class="nav navbar-nav">
      <!-- ngRepeat: folder in map[currentVersion] --><li class="dropdown ng-scope" ng-repeat="folder in map[currentVersion]">
        <a ng-href="#/scalr/concepts" class="dropdown-toggle ng-binding" data-toggle="dropdown" role="button" aria-expanded="false" ng-bind="folder.label" href="#/scalr/concepts">Concepts</a>
        <ul class="dropdown-menu">
          <!-- ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/concepts/intro.html ng-bind="file.label" class="ng-binding" href=../../scalr/concepts/intro.html>Intro</a>
          </li><!-- end ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/concepts/datamodel.html ng-bind="file.label" class="ng-binding" href=../../scalr/concepts/datamodel.html>Data Model</a>
          </li><!-- end ngRepeat: file in folder.files -->
        </ul>
      </li><!-- end ngRepeat: folder in map[currentVersion] --><li class="dropdown ng-scope" ng-repeat="folder in map[currentVersion]">
        <a ng-href="#/scalr/javascript" class="dropdown-toggle ng-binding" data-toggle="dropdown" role="button" aria-expanded="false" ng-bind="folder.label" href="#/scalr/javascript">Javascript</a>
        <ul class="dropdown-menu">
          <!-- ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/javascript/javascript-intro.html ng-bind="file.label" class="ng-binding" href=../../scalr/javascript/javascript-intro.html>JS Quick Start</a>
          </li><!-- end ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/javascript/nodejs-intro.html ng-bind="file.label" class="ng-binding" href=../../scalr/javascript/nodejs-intro.html>Node Quick Start</a>
          </li><!-- end ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/javascript/api-reference.html ng-bind="file.label" class="ng-binding" href=../../scalr/javascript/api-reference.html>JS API Reference</a>
          </li><!-- end ngRepeat: file in folder.files -->
        </ul>
      </li><!-- end ngRepeat: folder in map[currentVersion] --><li class="dropdown ng-scope" ng-repeat="folder in map[currentVersion]">
        <a ng-href="#/scalr/rest" class="dropdown-toggle ng-binding" data-toggle="dropdown" role="button" aria-expanded="false" ng-bind="folder.label" href="#/scalr/rest">REST</a>
        <ul class="dropdown-menu">
          <!-- ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/rest/intro.html ng-bind="file.label" class="ng-binding" href=../../scalr/rest/intro.html>Quick Start</a>
          </li><!-- end ngRepeat: file in folder.files -->
        </ul>
      </li><!-- end ngRepeat: folder in map[currentVersion] --><li class="dropdown ng-scope" ng-repeat="folder in map[currentVersion]">
        <a ng-href="#/scalr/FAQs" class="dropdown-toggle ng-binding" data-toggle="dropdown" role="button" aria-expanded="false" ng-bind="folder.label" href="#/scalr/FAQs">FAQs</a>
        <ul class="dropdown-menu">
          <!-- ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/FAQs/jsapi.html ng-bind="file.label" class="ng-binding" href=../../scalr/FAQs/jsapi.html>JS API</a>
          </li><!-- end ngRepeat: file in folder.files --><li ng-repeat="file in folder.files" class="ng-scope">
            <a ng-href=../../scalr/FAQs/rest.html ng-bind="file.label" class="ng-binding" href=../../scalr/FAQs/rest.html>REST</a>
          </li><!-- end ngRepeat: file in folder.files -->
        </ul>
      </li><!-- end ngRepeat: folder in map[currentVersion] -->
    </ul>

    <ul class="nav navbar-nav navbar-right">      
       <li class="dropdown search-dropdown">
        <div class="form-group search-form" data-ng-class="{'open-in':search.length &gt; 0}">
          <input data-ng-model="search" type="text" class="search form-control dropdown-toggle ng-pristine ng-untouched ng-valid" data-toggle="dropdown" aria-expanded="false" placeholder="search..">
          <ul class="dropdown-menu search-box ng-hide" role="menu" data-ng-show="search.length &gt; 0">
            <!-- ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="../../" class="ng-binding">Appbase Documentation</a>
              <span class="hide ng-binding">Appbase Documentation</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-model" class="ng-binding">APPBASE DATA MODEL</a>
              <span class="hide ng-binding">Appbase Data Model</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-model-what-is-appbaseio" class="ng-binding">WHAT IS APPBASE.IO</a>
              <span class="hide ng-binding">What is appbase.ioAppbase.io is a data streams API service for continuous search and aggregation queries. You can build reactive apps with Appbase.io, where views update in conjunction with the data changes.It enables you to:  Image 1: It provides a reliable data streams API as a service, while leveraging ElasticSearch (and Lucene) for storage and search.While not primarily intended, Appbase.io can also be used as a hosted ElasticSearch API or as a message queue with a publish / subscribe model.There are some catches if you intend to:  </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-schema" class="ng-binding">APPBASE DATA SCHEMA</a>
              <span class="hide ng-binding">Appbase Data SchemaAppbase uses the same data schema as ElasticSearch.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-schema-app-aka-index" class="ng-binding">APP AKA INDEX</a>
              <span class="hide ng-binding">App aka IndexAn app in appbase.io is stored as an index in ElasticSearch. App is the highest level of construct supported by appbase and is equivalent to a database in SQL.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-schema-type" class="ng-binding">TYPE</a>
              <span class="hide ng-binding">TypeTypes are equivalent to tables in SQL. Data in an app is always stored within it’s types. A good way to think of them is as collections of different kinds of data.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-schema-document" class="ng-binding">DOCUMENT</a>
              <span class="hide ng-binding">DocumentA document is the actual data stored in Appbase. Documents are JSON objects, equivalent to records or rows in SQL.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/datamodel/#appbase-data-schema-visualizing-the-data-model" class="ng-binding">VISUALIZING THE DATA MODEL</a>
              <span class="hide ng-binding">Visualizing the Data ModelAn app can have one or more types and each type is a container for JSON documents. Visually, the arrangement looks like below:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/#major-changes" class="ng-binding">MAJOR CHANGES</a>
              <span class="hide ng-binding">Major changes</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/#major-changes-1-json-document-based-model" class="ng-binding">1. JSON Document based Model</a>
              <span class="hide ng-binding">1. JSON Document based ModelWith v3.0, Appbase adopts the JSON based document schema model (similar to MongoDB and ElasticSearch). We are bringing the simplicity of JSON based data models to Appbase with this major revision while still maintaining index-free adjency references for each document.Here’s how the mapping works if you are familiar with the v2.0 API:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/#major-changes-2-rest-api-format" class="ng-binding">2. REST API Format</a>
              <span class="hide ng-binding">2. REST API FormatThe overall API format has been made more expressive.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#api-prime-objective-scale" class="ng-binding"> API PRIME OBJECTIVE: SCALE</a>
              <span class="hide ng-binding"> API Prime Objective: ScaleAs the name suggests, our prime focus with this iteration of the API has been achieving a massive scale of API operations, to the tune of 100,000 writes and reads (yet to corroborate) per second. You might wonder - why is addressing scale so important? A typical successful application would never exceed a throughput of a  few hundred requests per second and generally be okay with serving responses in time.So much complexity in software comes from trying to make one thing do two things.-Ryan SingerThis quote from Ryan Singer especially sings true when one thinks of scaling database operations. So much of the software service complexities stem from keeping up with the infrastructure needs, that those end up turning into burning pain points. It should come as no surprise that most mainstream distributed systems were born out of the scaling pain points faced by the 0.01% of applications.Not only does addressing scale solve the burning pain points faced by the 0.01%, it provides confidence around the edge-cases and leads to faster adoption in production environments and success stories. We hope all of these come true for SCALR. In building SCALR, focusing on scale has lead us to a better foundational design, a more rigorously tested codebase, and a fine-grained monitoring of our deployment infrastructure. We’ll go more in depth about these learnings over the next few months, but most importantly - for the 99.9% folks reading this, SCALR has tons of improvements and features over v2.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human" class="ng-binding">GIT DIFF CHANGES - - HUMAN</a>
              <span class="hide ng-binding">git diff changes - -  humanWelcome to the land of SCALR, where everyone smiles and the sun shines bright. Our beloved Hobo Lobo is chalking a ‘SCALR’ 101. “changes what?”, asks someone.“Everything”, says Hobo Lobo rather curtly.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-scalr-whats-in-a-name" class="ng-binding">SCALR - WHAT’S IN A NAME</a>
              <span class="hide ng-binding">SCALR - What’s in a nameThe most tangible change is in the codename - scalr. Breaking the convention of keeping a dull version name like v2.0, we will go with the version scalr. Docs for scalr are available at http://docs.appbase.io/ and the API base URL would be https://scalr.api.appbase.io.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch" class="ng-binding">COMPATIBILITY WITH ELASTICSEARCH</a>
              <span class="hide ng-binding">Compatibility with ElasticSearchscalr is compatible out of the box with the ElasticSearch APIs. This means our users can take advantage of the vast plethora of client libraries made available by the folks at Elastic, have access to a vibrant open-source community and have the freedom to import / export data from Appbase.io conveniently. </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication" class="ng-binding">HTTP Basic Authentication</a>
              <span class="hide ng-binding">HTTP Basic Authenticationscalr uses HTTP Basic Authentication for securing app access (similar to Github and Wordpress’s authentication mechanisms). Every Appbase app can have one or more access tokens (username, password) with differing read and write permissions to allow fine-grained access. ElasticSearch’s access tokens work in the same way, a major compatibility win.Note: This is a change from the earlier use of authentication header called Appbase-Secret.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible" class="ng-binding">What’s not compatible?</a>
              <span class="hide ng-binding">What’s not compatible?The APIs related to devops, like clusters, multi-index operations, index creation are not a part of Appbase.io. Appbase is opinionated about devops.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-data-streams-20" class="ng-binding">DATA STREAMS 2.0</a>
              <span class="hide ng-binding">Data Streams 2.0Data Streams aka realtime events are rethought in SCALR. Instead of being a websockets based extension of the API to track just the document and reference changes, data streams are deeply baked into the SCALR API. Data Streams are implemented over both websockets (for browsers) and http-streaming (for other runtimes) and are pervasive over web, mobile and language native libraries. Data Streams can stream results of queries and filters as new data comes into the system.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/#git-diff-changes-human-adieu-to-graph-datamodel" class="ng-binding">ADIEU TO GRAPH DATAMODEL</a>
              <span class="hide ng-binding">Adieu to Graph datamodelSCALR the JSON based schema-free datamodel of ElasticSearch. This is a major change over the graph datamodel extensively used by the v2 API. The move is aimed at simplicity and to provide a less opinionated data model. True graph relationships can still be modeled in SCALR.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/jsapi/#how-to" class="ng-binding">HOW TO</a>
              <span class="hide ng-binding">How to</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/jsapi/#how-to-unsubscribe-from-a-streaming-query" class="ng-binding">UNSUBSCRIBE FROM A STREAMING QUERY</a>
              <span class="hide ng-binding">Unsubscribe from a streaming queryThe JS API methods for the appbaseRef object implement a streams interface. Let’s see an example:Unsubscribing from the responseStream is simple: using stop() method. The same is true for all other methods (like index(), getStream()) as well, data is returned asynchronously via the ‘data’ event handler.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/jsapi/#how-to-pause-a-streaming-query" class="ng-binding">PAUSE A STREAMING QUERY</a>
              <span class="hide ng-binding">Pause a streaming queryPausing a response stream object prevents new data responses from emitting. The stream can be resumed again via conveniently named responseStream.resume(). pause() vs stop() - pause() merely prevents emitting new responses in the ‘data’ event handler, all the response stream object buffers the new events emitted by the searchStream() method. When resume() is called, all these responses are returned by the ‘data’ event handler. By contrast, stop() unsubscribes from the query and kills the response stream object. Check out more things you can do with streams here -  http://www.sitepoint.com/basics-node-js-streams/.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/jsapi/#how-to-stream-results-of-a-range-query" class="ng-binding">STREAM RESULTS OF A RANGE QUERY</a>
              <span class="hide ng-binding">Stream results of a range queryAppbase.io implements a streaming interface for the entire Query DSL supported by ElasticSearch. So if we can compose a range query, making it return continuous results is easy.Let’s say we have a type called items which contains items with their corresponding value. An example document inside the items type looks like:Composing the query:The default state of responseStream object is paused. As soon as attach a data handler to it, it will start streaming the responses.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/jsapi/#how-to-change-the-default-results-in-a-search-query" class="ng-binding">CHANGE THE DEFAULT RESULTS IN A SEARCH QUERY</a>
              <span class="hide ng-binding">Change the default results in a search queryAppbase returns 10 objects in the initial response to searchStream() method. Sometimes, we need to return more objects. We can do this by specifying the size attribute inside our query like this:The responseStream object will now return max(total_objects_matching_our_query, 100) objects on the 'data' event handler. The size attribute can specify a maximum of 1000 objects to return in one response. size attribute can be applied on both searchStream() and search() methods.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#api-prime-objective-scale" class="ng-binding"> API PRIME OBJECTIVE: SCALE</a>
              <span class="hide ng-binding"> API Prime Objective: ScaleAs the name suggests, our prime focus with this iteration of the API has been achieving a massive scale of API operations, to the tune of 100,000 writes and reads (yet to corroborate) per second. You might wonder - why is addressing scale so important? A typical successful application would never exceed a throughput of a  few hundred requests per second and generally be okay with serving responses in time.So much complexity in software comes from trying to make one thing do two things.-Ryan SingerThis quote from Ryan Singer especially sings true when one thinks of scaling database operations. So much of the software service complexities stem from keeping up with the infrastructure needs, that those end up turning into burning pain points. It should come as no surprise that most mainstream distributed systems were born out of the scaling pain points faced by the 0.01% of applications.Not only does addressing scale solve the burning pain points faced by the 0.01%, it provides confidence around the edge-cases and leads to faster adoption in production environments and success stories. We hope all of these come true for SCALR. In building SCALR, focusing on scale has lead us to a better foundational design, a more rigorously tested codebase, and a fine-grained monitoring of our deployment infrastructure. We’ll go more in depth about these learnings over the next few months, but most importantly - for the 99.9% folks reading this, SCALR has tons of improvements and features over v2.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human" class="ng-binding">GIT DIFF CHANGES - - HUMAN</a>
              <span class="hide ng-binding">git diff changes - -  humanWelcome to the land of SCALR, where everyone smiles and the sun shines bright. Our beloved Hobo Lobo is chalking a ‘SCALR’ 101. “changes what?”, asks someone.“Everything”, says Hobo Lobo rather curtly.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-scalr-whats-in-a-name" class="ng-binding">SCALR - WHAT’S IN A NAME</a>
              <span class="hide ng-binding">SCALR - What’s in a nameThe most tangible change is in the codename - scalr. Breaking the convention of keeping a dull version name like v2.0, we will go with the version scalr. Docs for scalr are available at http://docs.appbase.io/ and the API base URL would be https://scalr.api.appbase.io.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch" class="ng-binding">COMPATIBILITY WITH ELASTICSEARCH</a>
              <span class="hide ng-binding">Compatibility with ElasticSearchscalr is compatible out of the box with the ElasticSearch APIs. This means our users can take advantage of the vast plethora of client libraries made available by the folks at Elastic, have access to a vibrant open-source community and have the freedom to import / export data from Appbase.io conveniently. </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication" class="ng-binding">HTTP Basic Authentication</a>
              <span class="hide ng-binding">HTTP Basic Authenticationscalr uses HTTP Basic Authentication for securing app access (similar to Github and Wordpress’s authentication mechanisms). Every Appbase app can have one or more access tokens (username, password) with differing read and write permissions to allow fine-grained access. ElasticSearch’s access tokens work in the same way, a major compatibility win.Note: This is a change from the earlier use of authentication header called Appbase-Secret.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible" class="ng-binding">What’s not compatible?</a>
              <span class="hide ng-binding">What’s not compatible?The APIs related to devops, like clusters, multi-index operations, index creation are not a part of Appbase.io. Appbase is opinionated about devops.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-data-streams-20" class="ng-binding">DATA STREAMS 2.0</a>
              <span class="hide ng-binding">Data Streams 2.0Data Streams aka realtime events are rethought in SCALR. Instead of being a websockets based extension of the API to track just the document and reference changes, data streams are deeply baked into the SCALR API. Data Streams are implemented over both websockets (for browsers) and http-streaming (for other runtimes) and are pervasive over web, mobile and language native libraries. Data Streams can stream results of queries and filters as new data comes into the system.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/concepts/intro/#git-diff-changes-human-adieu-to-graph-datamodel" class="ng-binding">ADIEU TO GRAPH DATAMODEL</a>
              <span class="hide ng-binding">Adieu to Graph datamodelSCALR the JSON based schema-free datamodel of ElasticSearch. This is a major change over the graph datamodel extensively used by the v2 API. The move is aimed at simplicity and to provide a less opinionated data model. True graph relationships can still be modeled in SCALR.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api" class="ng-binding">QUICK START TO THE  JS API</a>
              <span class="hide ng-binding">Quick Start to the  JS APIAppbase.JS is a minimalistic library for data streams.  It can:It can’t:  Appbase is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.This is a quick start guide to whet the appetite with the possibilities of data streams.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-0-creating-an-app" class="ng-binding">STEP 0: CREATING AN APP</a>
              <span class="hide ng-binding">Step 0: Creating an AppLog in to  Appbase Dashboard, and create a new app.For this tutorial, we will use an app called “createnewtestapp01”. The &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.SCALR uses HTTP Basic Auth, a widely used protocol for a simple username/password authentication.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-1-lib-setup" class="ng-binding">STEP 1: LIB SETUP</a>
              <span class="hide ng-binding">Step 1: Lib SetupWe will fetch and install the appbase-js lib using bower. We will use v0.9.0 for specificity. Requiring the lib takes just one line of html script injection:To write data or stream updates from appbase.io, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the Appbase constructor:ORAlternatively, username:password can be passed as a part of the API URL in the constructor.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-2-storing-data" class="ng-binding">STEP 2: STORING DATA</a>
              <span class="hide ng-binding">Step 2: Storing DataOnce we have the reference object (called appbaseRef in this tutorial), we can insert any JSON object into it with the index() method.where type: 'books' indicate the collection (or table) inside which the data will be stored and theid: '1' is an optional unique identifier.The index() method (and all the other appbase methods) return a stream object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes. If you have noticed, SCALR uses the same APIs and data modeling conventions as ElasticSearch. A type is equivalent to a collection in MongoDB or a table in SQL, and a document is similar to the document in MongoDB and equivalent to a row in SQL.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-vs-streaming-data" class="ng-binding">STEP 3: GETING VS STREAMING DATA</a>
              <span class="hide ng-binding">Step 3: GETing vs Streaming DataUnlike typical databases that support GET operations (or Read) for fetching data and queries, Appbase.io operates on both GET and stream modes. We will first apply the GET mode to read our just inserted object.Now that we are able to store data, let’s try to get the data back from appbase.io with the get() method.Even though get() returns a single document data, appbase.io returns it as a stream object with the ‘data’ event handler.Let’s say that we are interested in subscribing to all the state changes that happen on a document. Here, we would use the getStream() method over get(), which keeps returning new changes made to the document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-vs-streaming-data-3a-subscribing-to-document-stream" class="ng-binding">3.a: Subscribing to document stream</a>
              <span class="hide ng-binding">3.a: Subscribing to document streamDon’t be surprised if you don’t see anything printed, getStream() only returns when new updates are made to the document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-vs-streaming-data-3b-observe-the-updates-in-realtime" class="ng-binding">3.b: Observe the updates in realtime</a>
              <span class="hide ng-binding">3.b: Observe the updates in realtimeLet’s see live updates in action. We will modify the book price in our original jsonObject variable from 5595 to 6034 and apply index() again.For brevity, we will not show the index() operation here.In the new document update, we can see the price change (5595 -&amp;gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.Note: Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by persisting the state using a composition of (_type, _id) fields.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-4-streaming-rich-queries" class="ng-binding">STEP 4: STREAMING RICH QUERIES</a>
              <span class="hide ng-binding">Step 4: Streaming Rich QueriesStreaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data changes? The searchStream() method scratches this itch perfectly. In the example below, we will see it in action with a match_all query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.Note: Like getStream(), searchStream() subscribes to the new matches. For fetching existing search results, check out search().In this tutorial, we have learnt how to index new data and stream both individual data and results of an expressive query. Appbase.io supports a wide range of queries.For next steps, check out our Javascript API reference.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api" class="ng-binding">QUICK START TO THE  REST API:</a>
              <span class="hide ng-binding">Quick Start to the  REST API:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-0-creating-an-app" class="ng-binding">STEP 0: CREATING AN APP</a>
              <span class="hide ng-binding">Step 0: Creating an AppLog in to  Appbase Dashboard, and create a new app.For this tutorial, we will use an app called “createnewtestapp01”. The &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.SCALR uses HTTP Basic Auth, a widely used protocol for simple username/password authentication. This is similar to how GitHub’s authentication works over https, just imagine every repository (app in our context) having it’s unique &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; combination.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-1-making-requests" class="ng-binding">STEP 1: MAKING REQUESTS</a>
              <span class="hide ng-binding">Step 1: Making RequestsHere’s an example authenticated GET request. We will set the app name, username and password as bash variables and reuse them in the requests.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-1-storing-data" class="ng-binding">STEP 1: STORING DATA</a>
              <span class="hide ng-binding">Step 1: Storing DataLet’s insert a JSON object. We create a type books inside our app and add a JSON document 1 with a PUT request.If you have noticed, SCALR uses the same APIs as ElasticSearch. A type is equivalent to a collection in MongoDB or a table in SQL, and a document is similar to the document in MongoDB and equivalent to a row in SQL.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data" class="ng-binding">STEP 2: GETING ERR, STREAMING DATA</a>
              <span class="hide ng-binding">Step 2: GETing err, Streaming DataGetting live updates to a document is as simple as suffixing ?stream=true to a GET request. It’s so awesome that we recommend using this as the default way to GET things.Appbase.io keeps an open connection so that every time there is an update in the /$app/books/1 document, it is streamed via the connection.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2a-modify-the-document" class="ng-binding">Step 2.a: Modify the Document</a>
              <span class="hide ng-binding">Step 2.a: Modify the DocumentLet’s modify the book price to 6034.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2b-observe-the-streams" class="ng-binding">Step 2.b: Observe the Streams</a>
              <span class="hide ng-binding">Step 2.b: Observe the StreamsIn the new document update, we can see the price change (5595 -&amp;gt; 6034) being reflected. Subsequent changes will be streamed to the resonse as raw JSON objects. As we see, there are no delimiters between between two consecutive JSON responses.For every ?stream=true request, Appbase.io keeps an open connection up to a max of 6 hrs.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/rest/intro/#quick-start-to-the-rest-api-step-3-streaming-search" class="ng-binding">STEP 3: STREAMING SEARCH</a>
              <span class="hide ng-binding">Step 3: Streaming SearchStreaming document updates seems straightforward, can we apply rich filters and queries to our streams? Yes, we can. We can specify any ElasticSearch Query DSL request, and get responses via streams.We will see it here with a match_all query request.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/rest/#how-to" class="ng-binding">HOW TO</a>
              <span class="hide ng-binding">How to</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data" class="ng-binding">UPDATE MAPPING WITHOUT LOSING DATA</a>
              <span class="hide ng-binding">Update mapping without losing dataAlthough you can add new types to an index, or add new fields to a type, you can’t add new analyzers or make changes to existing fields. If you were to do so, the data that had already been indexed would be incorrect and your searches would no longer work as expected. Here’s a short gist on how mappings work:In order to make your data searchable, your database needs to know what type of data each field contains and how it should be indexed. If you switch a field type from e.g. a string to a date, all of the data for that field that you already have indexed cannot be used because of the datatype mismatch. In such situations, you need to reindex that field.This applies not just to Appbase (or Elasticsearch / Lucene - the datastore used by Appbase), but to any database that uses indices for searching. And if it isn’t using indices then it is sacrificing speed for flexibility.There is one situation where re-indexing is not required: when adding a field, as a previous mapping for the field didn’t exist and Appbase can infer the field datatype when it’s indexed for the first time.Since updating mapping =&amp;gt; reindexing data, let’s take a look at that.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data-reindexing-your-data" class="ng-binding">Reindexing your data</a>
              <span class="hide ng-binding">Reindexing your dataThe process for reindexing your data is quite simple. First, create a new app in appbase and update the new mapping and settings:  One of the advantages of the _source field is that you already have the whole document available to you in Elasticsearch itself. You don’t have to rebuild your index from the database, which is usually much slower.To reindex all of the documents from the old index efficiently, use scan-and-scroll to retrieve batches of documents from the old index, and the bulk API to push them into the new index.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data-reindexing-in-batches" class="ng-binding">Reindexing in Batches</a>
              <span class="hide ng-binding">Reindexing in BatchesYou can run multiple reindexing jobs at the same time, but you obviously don’t want their results to overlap. Instead, break a big reindex down into smaller jobs by filtering on a date or timestamp field:  If you continue making changes to the old app, you will want to make sure that you include the newly added documents in your new app as well. This can be done by rerunning the reindex process, but again filtering on a date field to match only documents that have been added since the last reindex process started.Reference: Elastic Search blog</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api" class="ng-binding">QUICK START TO THE  NODE.JS API</a>
              <span class="hide ng-binding">Quick Start to the  Node.JS APIAppbase.JS is a minimalistic library for data streams.  It can:It can’t:  Also, Appbase is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.This is a quick start guide to whet the appetite with the possibilities of data streams.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-0-creating-an-app" class="ng-binding">STEP 0: CREATING AN APP</a>
              <span class="hide ng-binding">Step 0: Creating an AppLog in to  Appbase Dashboard, and create a new app.For this tutorial, we will use an app called “createnewtestapp01”. The &amp;lt;username&amp;gt;:&amp;lt;password&amp;gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.SCALR uses HTTP Basic Auth, a widely used protocol for a simple username/password authentication.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-1-lib-setup" class="ng-binding">STEP 1: LIB SETUP</a>
              <span class="hide ng-binding">Step 1: Lib SetupWe will fetch and install the appbase-js lib via npm, current version should be v0.9.0.Requiring the lib takes one line:To write data or stream updates from appbase.io, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the Appbase constructor:ORAlternatively, username:password can be passed as a part of the API URL in the constructor.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-2-storing-data" class="ng-binding">STEP 2: STORING DATA</a>
              <span class="hide ng-binding">Step 2: Storing DataOnce we have the reference object (called appbaseRef in this tutorial), we can insert any JSON object into it with the index() method.where type: 'books' indicate the collection (or table) inside which the data will be stored and theid: '1' is an optional unique identifier.The index() method (and all the other appbase methods) return a stream object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes. If you have noticed, SCALR uses the same APIs and data modeling conventions as ElasticSearch. A type is equivalent to a collection in MongoDB or a table in SQL, and a document is similar to the document in MongoDB and equivalent to a row in SQL.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data" class="ng-binding">STEP 3: GETING VS STREAMING DATA</a>
              <span class="hide ng-binding">Step 3: GETing vs Streaming DataUnlike typical databases that support GET operations (or Read) for fetching data and queries, Appbase.io operates on both GET and stream modes. We will first apply the GET mode to read our just inserted object.Now that we are able to store data, let’s try to get the data back from appbase.io with the get() method.Even though get() returns a single document data, appbase.io returns it as a stream object with the ‘data’ event handler.Let’s say that we are interested in subscribing to all the state changes that happen on a document. Here, we would use the getStream() method over get(), which keeps returning new changes made to the document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data-3a-subscribing-to-document-stream" class="ng-binding">3.a: Subscribing to document stream</a>
              <span class="hide ng-binding">3.a: Subscribing to document streamDon’t be surprised if you don’t see anything printed, getStream() only returns when new updates are made to the document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data-3b-observe-the-updates-in-realtime" class="ng-binding">3.b: Observe the updates in realtime</a>
              <span class="hide ng-binding">3.b: Observe the updates in realtimeLet’s see live updates in action. We will modify the book price in our original jsonObject variable from 5595 to 6034 and apply index() again.For brevity, we will not show the index() operation here.In the new document update, we can see the price change (5595 -&amp;gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.Note: Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by persisting the state using a composition of (_type, _id) fields.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-4-streaming-rich-queries" class="ng-binding">STEP 4: STREAMING RICH QUERIES</a>
              <span class="hide ng-binding">Step 4: Streaming Rich QueriesStreaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data changes? The searchStream() method scratches this itch perfectly. In the example below, we will see it in action with a match_all query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.Note: Like getStream(), searchStream() subscribes to the new matches. For fetching existing search results, check out search().In this tutorial, we have learnt how to index new data and stream both individual data and results of an expressive query. Appbase.io supports a wide range of queries.For next steps, check out our Javascript API reference.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference" class="ng-binding">JAVASCRIPT API REFERENCE</a>
              <span class="hide ng-binding">Javascript API ReferenceAppbase.JS is a minimalistic library for data streams.It can:You can read the Javascript or Node.JS quick-start guides for installation and basic usage.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-setup" class="ng-binding">SETUP</a>
              <span class="hide ng-binding">SETUP</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-setup-new-appbase" class="ng-binding">new Appbase()</a>
              <span class="hide ng-binding">new Appbase()Returns a new Appbase object (refered to as appbaseRef in all the following examples) using the url, appname and username:password credentials.Usagenew Appbase(appData)appData Object - A Javascript object containing the following fields and valuesReturnsObject appbaseRef Appbase reference object - has index(), delete(), bulk(), search(), get(), getTypes(), getStream() and searchStream() methods.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-writing-data" class="ng-binding">WRITING DATA</a>
              <span class="hide ng-binding">WRITING DATA</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-index" class="ng-binding">index()</a>
              <span class="hide ng-binding">index()Writes a JSON data object at a given type and id location, or updates if an object already exists.UsageappbaseRef.index(params)params Object - A Javascript object containing the type, id and the JSON data to be indexed</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-delete" class="ng-binding">delete()</a>
              <span class="hide ng-binding">delete()Delete a JSON data object by id.UsageappbaseRef.delete(params)params Object - A Javascript object containing the type and id of the JSON object to be deleted</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-bulk" class="ng-binding">bulk()</a>
              <span class="hide ng-binding">bulk()Apply many index / delete operations together, useful when importing data for the first time.UsageappbaseRef.bulk(params)params Object - A Javascript object containing the body and optionally a default type to be used for actions</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-getting-data" class="ng-binding">GETTING DATA</a>
              <span class="hide ng-binding">GETTING DATA</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-get" class="ng-binding">get()</a>
              <span class="hide ng-binding">get()Get the JSON document from a particular type and id. For subscribing to realtime updates on a document, check out getStream().UsageappbaseRef.get(params)Returns the document at the given type and id.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-gettypes" class="ng-binding">getTypes()</a>
              <span class="hide ng-binding">getTypes()Get all the types of an appname.UsageappbaseRef.getTypes()Returns all the types as an array.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-search" class="ng-binding">search()</a>
              <span class="hide ng-binding">search()Search for matching documents in a type. It’s a convenience method for ElasticSearch’s /_search endpoint.  For subscribing to realtime updates on the search query, check out searchStream().UsageappbaseRef.search(params)params Object - A Javascript object containing the query type and body.Returnsstream.Readable Object with</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data" class="ng-binding">STREAMING DATA</a>
              <span class="hide ng-binding">STREAMING DATA</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data-getstream" class="ng-binding">getStream()</a>
              <span class="hide ng-binding">getStream()Continuously stream new updates to a specific JSON document. If you wish to only fetch the existing value, get() is sufficient.UsageappbaseRef.getStream(params)params Object - A Javascript object containing the type and id of the document to be streamed. The streamOnly field parameter is deprecated starting v0.9.0 onwards, and is the default for how getStream() works (previously readStream()).Returnsstream.Readable Object withNote: appbase.js lib uses websockets to stream the updates.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data-searchstream" class="ng-binding">searchStream()</a>
              <span class="hide ng-binding">searchStream()Continuously stream results of search query on a given type. Search queries can be a variety of things: from simple monitoring queries, finding an exact set of documents, full-text search queries, to geolocation queries.searchStream() only returns new search results after the query is performed, existing search results can be obtained via search() method.UsageappbaseRef.searchStream(params)params Object - A Javascript object containing the query type and body The streamOnly field parameter is deprecated starting v0.9.0 onwards, and is the default for how searchStream() works.Returnsstream.Readable Object with</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/changelog/changelog/#major-changes" class="ng-binding">MAJOR CHANGES</a>
              <span class="hide ng-binding">Major changes</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/changelog/changelog/#major-changes-1-json-document-based-model" class="ng-binding">1. JSON Document based Model</a>
              <span class="hide ng-binding">1. JSON Document based ModelWith v3.0, Appbase adopts the JSON based document schema model (similar to MongoDB and ElasticSearch). We are bringing the simplicity of JSON based data models to Appbase with this major revision while still maintaining index-free adjency references for each document.Here’s how the mapping works if you are familiar with the v2.0 API:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/changelog/changelog/#major-changes-2-rest-api-format" class="ng-binding">2. REST API Format</a>
              <span class="hide ng-binding">2. REST API FormatThe overall API format has been made more expressive.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel" class="ng-binding">DATAMODEL</a>
              <span class="hide ng-binding">DatamodelAppbase is a realtime Database as a Service (DBaaS), built on top of a graph schema with JSON based vertices (similar to JSON documents), and edges to link them.All databases support the storing and fetching of data, what distinguishes one database type from another is the structure of the data they store and the means by which it can be retrieved. Several popular databases can be classified as below:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-data-in-appbase" class="ng-binding">DATA IN APPBASE</a>
              <span class="hide ng-binding">Data in AppbaseAppbase is a Directed Graph. Objects inside Appbase are called Vertices) (a graph term for entities), and the links (relationships) between the objects are called Edges.Data in Appbase is stored as JSON objects. Appbase supports flexible schema, i.e. the properties of the JSON object need not be defined in advance. Although Appbase supports storing embedded JSON objects and arrays, one doesn’t have to store data in this denormalized fashion. This is mainly for compatibility with existing document stores like MongoDB. The recommended approach is to create reference links between distint entities. In this doc, we will cover how you can store different kinds data (primitive values, objects, lists), create relationships amongst them, normalize, and do perform different queries on them.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts" class="ng-binding">CONCEPTS</a>
              <span class="hide ng-binding">ConceptsSimilar to how SQL has concepts for table, row, column, relation and MongoDB has collection , Document and fields, here are the key concepts in Appbase.Vertex — is similar to a Document in MongoDB, it stores data.  Namespace — is similar to a Collection in MongoDB or type in ElasticSearch. A vertex always belongs to a namespace and security rules can be applied on namespaces. Edge — is a directional link to another vertex.  i.e. an edge is pointed from inVertex to an outVertex.Path — Every vertex in Appbase has a path, starting from the &amp;lt;namespace&amp;gt; and ending at the vertex, not unlike the UNIX path. A typical path looks like &amp;lt;namespace&amp;gt;/&amp;lt;v1&amp;gt;/&amp;lt;v2&amp;gt;/…/&amp;lt;vn&amp;gt;/.URL — It is a way to point to a Path in the REST API. Paths are prefixed with the Appbase API base URL, application’s name and the API version. Eg. https://api.appbase.io/chat_app/v2/&amp;lt;path&amp;gt;/.We can not actually compare these concepts with other kinds of databases, but it helps to understand Appbase if we compare the usage practices.With this table in mind, lets understand how the concepts work.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts-vertex" class="ng-binding">Vertex</a>
              <span class="hide ng-binding">VertexVertex is the the standard data container in Appbase. A vertex can store a valid JSON object and be linked to other vertices via edges.It can also store nested JSON objects and arrays, but this is only for convenience. In practice, vertices act as singular data entities, i.e. you store only the data relevant to a single entity in the real world. For e.g. a person’s age, name, height, sex can be stored in a single vertex, but the data of his belongings, like a book or a car is a completely different entity. This new entity will have properties of its own and they should be stored inside a new vertex. Later in this document, we will see how we can create a relation between these two entities.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts-namespace" class="ng-binding">Namespace</a>
              <span class="hide ng-binding">NamespaceNamespaces are a way to combine similar entities. For eg. all vertices storing different users can be stored inside the user namespace and all the tweets (repreented as vertices) can be stored inside the tweet namespace. Since namespace is a logical container, different kinds of objects can be stored inside a single namespace. This allows searching for similar vertices and applying security rules with ease.Namespaces are searchable. We are using the open-source ElasticSearch behind the scenes to support this use-case. See this documentation for a quick intro on how search works.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts-edge-one-to-one-relationships" class="ng-binding">Edge (one-to-one relationships)</a>
              <span class="hide ng-binding">Edge (one-to-one relationships)After creating entities, its time to create relations amongst them via edges. An edge is a named directional link connecting two vertices for a purpose, a one-to-one relation. For instance, a book has an author, a husband has wife and a child has a mother. The edges for these would be book vertex --authouredBy-&amp;gt; person vertex, man vertex --marriedTo-&amp;gt; woman vertex. Edges are directional, so if you set the edge man --marriedTo-&amp;gt; woman, it only tells us that the man is married to the woman, but it tells us nothing about woman’s relationship status. For that, another edge, woman --marriedTo-&amp;gt; man, should be created.Appbase only allows for unique edge names. The default behaviour is last-write-wins in case a new edge is created with an existing name. Edges have priorities which are rational numbers (think of the Number datatype in Javascript).</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts-path" class="ng-binding">Path</a>
              <span class="hide ng-binding">PathPaths are the way to interact with vertices in Appbase. Paths are constructed with &amp;lt;namespace&amp;gt;/&amp;lt;vertexKey&amp;gt;/&amp;lt;edgeName_1&amp;gt;/…/&amp;lt;edgeName_N&amp;gt;/.Creating edges create deeper Paths. Lets take the example of the movie Inception, the Oscar deserver lead actor Leonardo DiCaprio, and the director Christopher Nolan. Here are the vertices stored in Appbase:These vertices can be accessed with the following paths, as entry points in the graph:Let’s create edges:With these edge, we created these deeper paths:movie/inception/leadActor : points to the same vertex as person/dicapriomovie/inception/directedBy : points to person/nolanperson/nolan/marriedTo: points to person/emmaHere’s the magic, the path movie/inception/directedBy/marriedTo points directly to person/emmaThis means, modifying the data stored at movie/inception/directedBy/marriedTo will change the data of person/emma as they both are the same vertices.Paths are powerful ways to point to the exact data you want to interact with. For e.g.  when you access the path movie/inception/directedBy/marriedTo, you are only interested in the vertex representing the person who is married to the director of Inception, and nothing else. You never access the data of the movie Inception, or the director.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-concepts-url" class="ng-binding">URL</a>
              <span class="hide ng-binding">URLA URL is just another representation of a Path. REST API URL looks like this: https://api.appbase.io/&amp;lt;app_name&amp;gt;/v2/&amp;lt;path&amp;gt;/. Assuming the Application’s name as imdb, URL for the path movie/inception/directedBy/marriedTo would be https://api.appbase.io/imdb/v2/movie/inception/directedBy/marriedTo</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-storing-data" class="ng-binding">STORING DATA</a>
              <span class="hide ng-binding">Storing DataBeing a Graph, Appbase allows you to create any kind of data structures you want, you just need to know exactly how. Lets see how to store the practical data structures we used on daily basis.The examples here use Appbase Javascript Library and if any of the method is confusing you, feel free to chekout the JS Documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-storing-data-primitive-data-and-json-objects" class="ng-binding">Primitive Data and JSON Objects</a>
              <span class="hide ng-binding">Primitive Data and JSON ObjectsNumbers, Characters, Strings and Booleans, are stored as values of the properties inside a vertex. Dates can be converted into the milliseconds since epoch, and store them as Numbers. For eg. you want to store a the movie’s name, and its release year, you can store combine all of them as a JSON object and store it inside a vertex.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-storing-data-nested-json-objects" class="ng-binding">Nested JSON Objects</a>
              <span class="hide ng-binding">Nested JSON ObjectsYou can store nested objects directly inside a vertex. E.g.This would work perfectly. Notice that you are not storing the director (Nolan) of Inception as a different entity, instead as a property of the movie itself. While this approach is sometimes handy, it limits you in terms of what you can do with Nolan. I.e. you will not be able to establish any direct relationships with Nolan, as it is not an entity in itself. For eg. Nolan is married to Emma, but there is no way to create a link between Nolan  and Emma, when it is stored as a nested object in Appbase.A better to do this is store Nolan as a new vertex, and create an edge from Inception to Nolan. You can create another vertex for Emma create edges with Nolan. We will create three edges here: inception --directedBy-&amp;gt; nolannolan --marriedTo-&amp;gt; emma
Recall that the edges are directional, so this 2nd edge only tells us that Nolan in married to Emma, but says nothing about Emma’s marital status. That’s why we create the third edge: emma --marriedTo-&amp;gt; nolanNotice that Inception directed by Nolan, is a One-to-One relationship. Nolan has directed many movies, and that’s a case of One-to-Many relationships. We see later how to create them in Appbase. </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-storing-data-sets-one-to-many-relationship" class="ng-binding">Sets (One-to-Many Relationship)</a>
              <span class="hide ng-binding">Sets (One-to-Many Relationship)A set makes sure that all the items in the list exist only once. Consider this example, the movies directed by Nolan. We will make only a small list here:  ["Interstellar", "Inception", "The Dark Night", "Memento"]. Clearly, it doesn’t make sense to have any of the movies twice in the this list.  Notice that this is a One-to-Many relationship here. Nolan (1) -&amp;gt; Movies (N).Operations on a single set are: addition, checking existence of an item, deletion and traversal. Operations on multiple sets, like union and intersection can be emulated using single-set operations. For e.g.Let’s see a practical set, the movies directed by Nolan. In Appbase, the Set is a vertex, let’s create it.Also the Items in the set are vertices.Now we have Appbase Vertex References to the Set and the Items, lets go through different set operations.Simply creating an edge from the Set to the Item. We will use the Primary Key (inceptionRef.name()) of the item as the name of the edge.Here, the important thing is to keep the edge-name exactly as the Vertex Key. That way makes sure that every item will exist only once in the set. For e.g. if you try to add inceptionRef again in the set, it will just replace the old edge no extra edges will be created.Keeping the edge-name same as the Vertex Key of the item, allows other operations as well, like deletion of an Item and checking where an Item exists.Remove the edge from Set to the Item.As we kept the edge name exactly as the Vertex Key, it means that we can use the Vertex Key to delete the edge as well.It’s not possible to check via the Item’s data, if the item exists or not. The only way we can check, is using the Vertex Key/edge-name. We see that if there’s an edge, with its name as the Vertex Key. We use outVertex() and isValid() for that. I.e. we are checking if the path set/moviesByNolan/&amp;lt;movieVertexKey&amp;gt; is valid or not.As all the items are the edges of the Set vertex, we simply fetch the edges of the Set vertex, and traverse through them.See Retrieving Data section.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-retrieving-data" class="ng-binding">RETRIEVING DATA</a>
              <span class="hide ng-binding">Retrieving DataIn a nutshell, Namspaces in Appbase have vertices, and vertices have properties, edges.Data retrieval in Appbase happens via realtime streams. These streams allows you to fetch existing data, and then keep listening to new data as well.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-retrieving-data-properties" class="ng-binding">Properties</a>
              <span class="hide ng-binding">PropertiesWhen you start listening to the properties of a vertex, you first get the existing properties, and then as the data keeps changing, the callback is called again with new properties.Appbase gives you the properties data as a snapshot. The snapshots are immutable copies of the data stored in a vertex. Any changes you make in the snapshot will not be stored in Appbase. If you don’t want to listen to the properties any more, you can turn the listener off with inceptionRef.off().For convenience, we have the method  inceptionRef.once() when you want to listen to daat just only once.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-retrieving-data-edges" class="ng-binding">Edges</a>
              <span class="hide ng-binding">EdgesRetrieving existing edges of a vertex is simple: just listen to edge_added event, which will return existing edges at first. When new edges are added, the callback will be fired for new edges as well.Notice that the if there are ‘N’ number of existing edges, the callback will be called ‘N’ times.eRef here is the Appbase Reference to the outVertex, and eSnap is the snapshot of the edge. Edge Snapshot is the snapshot of the data stored with the edge and the out vertex, mainly the priority of the edge, and the properties of the out vertex. eSnap.priority() will give you the priority, and eSnap.properties() will give you properties.With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them, or want to fetch only a particular edge.When more than one filter is provided, they work as logical AND and only the edges matchihg all filters will be fetched. This is what each filter means:Notice that:
 - Filters are a way to fetch existing edges, thus they work only with edge_added event
 - Edges are always returned ordered according to their priorities
 - When endAt &amp;lt; startAt, edges are returned in reverse order
 - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime
    - This means that the numeric filters can not be used with onlyNew set to be true
    - Newly created edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/#datamodel-retrieving-data-vertices-in-a-namespace" class="ng-binding">Vertices in a Namespace</a>
              <span class="hide ng-binding">Vertices in a NamespaceNamespaces are vertex containers, and it is possible to retrieve existing vertices, and listen to updates when new vertices are added or old vertices are removed.The callback attached with vertex_added event is called for all the existing vertices. As new vertices are added, it is called for them too.To listen to updates of vertex removal, use vertex_removed event.With ElasticSearch’s powerful APIs in the backend, Appbase supports full-text fuzzy search queries on the data stored into vertices of a namespace. A sample query on a namespace looks something like this: This query searches on all the vertices of the namespace movie, and returns an array of vertices who’s property year, matches fuzzily with the text “2010”. See this documentation for more details.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs" class="ng-binding">APPBASE.JS</a>
              <span class="hide ng-binding">appbase.jsJavaScript Wrapper for Appbase Rest API</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-1-appbase-global-object" class="ng-binding">1. APPBASE GLOBAL OBJECT</a>
              <span class="hide ng-binding">1. Appbase Global ObjectThe Appbase object is responsible for instantiating Apps.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-1-appbase-global-object-methods" class="ng-binding">Methods</a>
              <span class="hide ng-binding">MethodsAppbase.app(appname, secret)Used to create a new instance of a AppParameters:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-2-app-class" class="ng-binding">2. APP CLASS</a>
              <span class="hide ng-binding">2. App ClassThe App class has utility methods to manage the App’s collections.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-2-app-class-methods" class="ng-binding">Methods</a>
              <span class="hide ng-binding">Methods App.search(query)This method searches the App’s collections with the given query.View in the REST API DocsParameters:   Example  AppTest.listCollections()This method retrieves all the collections of the app.View in the REST API Docs  AppTest.serverTime()Returns the server timestamp in milliseconds.View in the REST API Docs  AppTest.collection(name)Returns a Collection object for the provided name  Parameters:  </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-3-collection-class" class="ng-binding">3. COLLECTION CLASS</a>
              <span class="hide ng-binding">3. Collection ClassProvides an interface to the Appbase’s REST endpoints to manage your collections.
View in the REST API Docs</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-properties" class="ng-binding">PROPERTIES</a>
              <span class="hide ng-binding">Properties</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/javascript/api-reference/#appbasejs-methods" class="ng-binding">METHODS</a>
              <span class="hide ng-binding">Methodscollection.search(query)
Searches the collection’s documents with the provided query.
View in the REST API DocsParameters:  collection.insert(entry)
Create a new document in the collection
View in the REST API DocsParameters:  collection.set(key, entry)
Create or update a new document in the collection, with the provided key as the id of that object.
View in the REST API DocsParameters:  collection.unset(key, properties)
Delete specific (or all) data properties of a document.
View in the REST API DocsParameters:  collection.get(key)
Read the existing document properties.
View in the REST API DocsParameters:  collection.getAll([filters])
List the documents in the collection. Returns an array of documents in the given collection.
View in the REST API DocsParameters:  collection.on(key, callback[, errorCallback])
Listen to changes on the Document with the provided key.Parameters:  collection.onDocuments(callback[, errorCallback])
Listen to the creation or changes on any Document in the collection.Parameters:  collection.onRef(key, callback[, errorCallback])
Listen to the creation or changes of References on the Document that has the provided key.Parameters:  collection.setRef(key, ref, path[, priority])
Listen to the creation or changes of References on the Document that has the provided key.
View in the REST API DocsParameters:  collection.getRefs(key[, filters])
Get all the References of the Document with the provided key.
View in the REST API DocsParameters:  collection.unsetRefs(key, references)
Removes the provided References from the Document with the provided key.
View in the REST API DocsParameters:  collection.delete(key)
Removes the Document with the provided key from the collection.Parameters:  </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel" class="ng-binding">DATAMODEL</a>
              <span class="hide ng-binding">Datamodel</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-data-in-appbase" class="ng-binding">DATA IN APPBASE</a>
              <span class="hide ng-binding">Data in Appbase</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data" class="ng-binding">UNDERSTANDING DATA</a>
              <span class="hide ng-binding">Understanding Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data-document" class="ng-binding">Document</a>
              <span class="hide ng-binding">Document</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data-collection" class="ng-binding">Collection</a>
              <span class="hide ng-binding">Collection</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data-reference" class="ng-binding">Reference</a>
              <span class="hide ng-binding">Reference</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data-path" class="ng-binding">Path</a>
              <span class="hide ng-binding">Path</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-understanding-data-url" class="ng-binding">URL</a>
              <span class="hide ng-binding">URL</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-saving-data" class="ng-binding">SAVING DATA</a>
              <span class="hide ng-binding">Saving Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-saving-data-writing-data" class="ng-binding">Writing Data</a>
              <span class="hide ng-binding">Writing Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-saving-data-modifying-data" class="ng-binding">Modifying Data</a>
              <span class="hide ng-binding">Modifying Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries" class="ng-binding">RETRIEVING DATA AND QUERIES</a>
              <span class="hide ng-binding">Retrieving Data and Queries</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-retrieving-document-properties" class="ng-binding">Retrieving Document Properties</a>
              <span class="hide ng-binding">Retrieving Document Properties</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-references" class="ng-binding">References</a>
              <span class="hide ng-binding">References</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-streaming-vs-retrieval" class="ng-binding">Streaming vs Retrieval</a>
              <span class="hide ng-binding">Streaming vs Retrieval</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#security" class="ng-binding">SECURITY</a>
              <span class="hide ng-binding">Security</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#security-serverside" class="ng-binding">SERVERSIDE</a>
              <span class="hide ng-binding">Serverside</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#security-serverside-app-secret" class="ng-binding">App Secret</a>
              <span class="hide ng-binding">App Secret</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#security-clientside" class="ng-binding">CLIENTSIDE</a>
              <span class="hide ng-binding">Clientside</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#acidity" class="ng-binding">ACIDITY</a>
              <span class="hide ng-binding">ACIDity</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/concepts/datamodel/#performance" class="ng-binding">PERFORMANCE</a>
              <span class="hide ng-binding">Performance</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search" class="ng-binding">SEARCHING FOR A BETTER SEARCH?</a>
              <span class="hide ng-binding">Searching for a better Search?Building a good quality full-text search experience for an app is a hard problem if your data resides in traditional RDBMS systems. Even database systems like MongoDB have very nascent support for search, others like DynamoDB offer no support. The hard, real fact is that these systems are not designed with search as a use-case, and one is left with a very rudimentary support like exact search match, or in the worst case scenario, even scanning the DB tables.While there are great tools available for search, like Apache Solr and Elasticsearch, they have two big problems:1. It is not recommended to use ElasticSearch as a primary data store. So you are still stuck with the problem of streaming data from your primary store to a search database like ES.2. The documentation is intimidating. Really, it seems the docs are made for rocket scientists rather than your average app developer!We have thought about the Search problem really hard, and have come up with an elegant solution.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search" class="ng-binding">OUR APPROACH TO SEARCH</a>
              <span class="hide ng-binding">Our Approach to SearchAppbase takes the search problem head-on and indexes all the data that is ever stored in Appbase, allowing searching on all the data and relationships. We provide the ability to do the following kind of queries:1. Full-text search - including simple match queries, fuzzy search queries, and autocomplete
2. Numeric-range queries - when you want answers to “Give me all the products that cost between $50 and $100” or “fetch all pages from 5 to 10”,3. Geo spatial queries - ElasticSearch offers a lot of Geo Spatial queries. To name a few, you can compare distances, get a bounding box, determine shape,4. Sort queries - sort queries are more like filters to arrange data returned by one of above queries. You can sort the data using multiple “property” parameters.With Aggregation and Combining queries, the possibilities are endless.Here’s a primer to leverage these powerful search queries broken into three steps.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-1-create-an-app" class="ng-binding">1. Create an App</a>
              <span class="hide ng-binding">1. Create an AppLog into Appbase Dashboard, and create a new app. Once you create an app with a desired name, you should see an app dialog box appear as below.Image 1: App name, stats and credentialsClick the  icon to copy your secret into clipboard.We will need the app name and the secret in all our API calls. In this case, these would be my_app9 and 097b2b28b6a13cf2e53b6cecfec42b86. We trust you with our app’s secret!</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-2-store-some-data" class="ng-binding">2. Store some Data</a>
              <span class="hide ng-binding">2. Store some DataAppbase supports the document data model. You can store JSON objects (known as documents) with Appbase directly (similar to MongoDB documents, or RDBMS records). The documents are stored within a collection. Appbase supports a granular search which typically works on a collection. The search is based on the ElasticSearch DSL, and supports the entire query format.For brevity, let’s say we are storing user profiles that we would like to later search by different document properties. Here’s how a JSON user object might look:To store this data with Appbase, we will make a PATCH request via REST. You can read more about them in our REST API. Here’s how the request would like in our case:When you copy the above code, be sure to replace the Appbase-Secret header and the app name in the URL to match your credentials.Understanding the RequestTo store data, we do a PATCH request.URL: https://v3.api.appbase.io/my_app9/people/laura/~properties, whereHeadersHeaders in this request include the Appbase-Secret value.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data" class="ng-binding">3. Perform Search on Data</a>
              <span class="hide ng-binding">3. Perform Search on DataNow that we have successfully stored data, let’s perform a full-text search.Let’s search for users whose occupation is being a designer.The response that you get from Appbase is an array of JSON objects which match the query criteria.Response:There you go! Appbase’s search fetches results which are close to the search term, and you get the following object in response.Understanding the RequestTo perform a search, we do a POST request.URL: https://v3.api.appbase.io/my_app9v/people/~search, whereRequest HeadersHeaders are always the same for all REST API requests.Request BodyThe JSON query object that we send with this request:That’s it! In less than 10 minutes, we were able to add production grade search in your app.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/quick-start/#searching-for-a-better-search-full-text-and-more" class="ng-binding">FULL TEXT AND MORE</a>
              <span class="hide ng-binding">Full text and moreDo you want to customize the ‘fuzziness’ of your search? Or perhaps apply multiple queries and filter the data at the same time. If this has whetted your appetite, check out our main article over here. Search Usecases.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#introduction" class="ng-binding">INTRODUCTION</a>
              <span class="hide ng-binding">IntroductionThe Appbase API is based on REST principles. All operations including creation of new documents and references, fetching document (JSON) and references, deleting a document or a reference as well as searching through documents are RESTful.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#introduction-resource-types" class="ng-binding">Resource Types</a>
              <span class="hide ng-binding">Resource Types</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#introduction-allowed-http-request-types" class="ng-binding">Allowed HTTP Request Types</a>
              <span class="hide ng-binding">Allowed HTTP Request Types</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#introduction-authorization" class="ng-binding">Authorization</a>
              <span class="hide ng-binding">AuthorizationAppbase accepts one of the two methods of authorizations.In this document, we will be using the 1. method since it makes authorization distinct from the request data.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#introduction-base-uri" class="ng-binding">Base URI</a>
              <span class="hide ng-binding">Base URIBase URI is the fixed URI that is common for all the API request endpoints and is prefix to all the API requests. A base URI has two path variables: appname and api_version. A typical base URI looks like https://v3.api.appbase.io/&amp;lt;appname&amp;gt;/.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference" class="ng-binding">API REFERENCE</a>
              <span class="hide ng-binding">API Reference</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-introduction" class="ng-binding">INTRODUCTION</a>
              <span class="hide ng-binding">IntroductionThe Appbase API endpoints are divided between three types of different resources.A path consists of a document and one or more references. It’s similar to how symlinks work in *nix filesystems.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-global" class="ng-binding">GLOBAL</a>
              <span class="hide ng-binding">Global</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-global-server-time" class="ng-binding">Server Time</a>
              <span class="hide ng-binding">Server TimeExample RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-global-list-collections" class="ng-binding">List collections</a>
              <span class="hide ng-binding">List collectionsExample RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-global-search-collections" class="ng-binding">Search collections</a>
              <span class="hide ng-binding">Search collectionsSearch documents across one or more collections. Returns a JSON body matching the ElasticSearch response format. The matching search results are inside the hits.hits field as an array of documents. For more details, see more queries that can be done with this endpoint, including fuzzy search, numeric-range, geospatial and aggregation queries.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-collection" class="ng-binding">COLLECTION</a>
              <span class="hide ng-binding">Collection</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-collection-list-all-documents" class="ng-binding">List all documents</a>
              <span class="hide ng-binding">List all documentsList the documents in the collection. Returns an array of documents in the given collection.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-collection-search-documents-by-propertyies" class="ng-binding">Search Documents by property(ies)</a>
              <span class="hide ng-binding">Search Documents by property(ies)Search documents by one or more document properties. Returns a JSON body matching the ElasticSearch response format. The matching search results are inside the hits.hits field as an array of documents. For more details, see other queries that can be done with this endpoint, including fuzzy search, numeric-range, geospatial and aggregation queries.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-properties" class="ng-binding">DOCUMENT PROPERTIES</a>
              <span class="hide ng-binding">Document PropertiesAll data operations on a document happen via Document Properties endpoint.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-properties-create-update-document-properties" class="ng-binding">Create / Update Document Properties</a>
              <span class="hide ng-binding">Create / Update Document PropertiesCreate a new document with some properties or update the properties of an existing document.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-properties-read-document-properties" class="ng-binding">Read Document Properties</a>
              <span class="hide ng-binding">Read Document PropertiesRead the existing document properties.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-properties-delete-document-properties" class="ng-binding">Delete document properties</a>
              <span class="hide ng-binding">Delete document propertiesDelete specific (or all) data properties of a document.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-references" class="ng-binding">DOCUMENT REFERENCES</a>
              <span class="hide ng-binding">Document References</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-references-create-update-document-references" class="ng-binding">Create / Update Document References</a>
              <span class="hide ng-binding">Create / Update Document ReferencesCreate a new reference or update the existing reference(s). A priority, which acts as an index can optionally be set on the reference.Example Request  Usage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-references-read-references" class="ng-binding">Read References</a>
              <span class="hide ng-binding">Read ReferencesFetch the document references.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-document-references-delete-references" class="ng-binding">Delete References</a>
              <span class="hide ng-binding">Delete ReferencesDelete specific (or all) document references.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/rest/api-reference/#api-reference-delete-document" class="ng-binding">DELETE DOCUMENT</a>
              <span class="hide ng-binding">Delete DocumentDeletes the document (including all properties, references), the document path itself will not resolve after this operation, i.e. a retrieval will result in a 101: Resource does not exist error.Example RequestUsage:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases" class="ng-binding">USE-CASES</a>
              <span class="hide ng-binding">Use-casesAppbase uses Elasticsearch in the backend, and provides all the search queries and filters supported by ES, on the data stored in Appbase. Every data that’s pushed into Appbase is automatically indexed on ElasticSearch.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-elasticsearch-introduction" class="ng-binding">ELASTICSEARCH INTRODUCTION</a>
              <span class="hide ng-binding">Elasticsearch IntroductionElasticSearch is powered by Lucene, a powerful open-source full-text search library, under the hood. More than just full-text queries, ES can be used for numeric range queries, geo spatial queries, aggregation/ordering/grouping search results etc. In addition, we can combine these queries (logical and/or) and search across multiple collections and properties. To learn more about Elasticsearch, checkout this very effective guide.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-data-mapping" class="ng-binding">DATA MAPPING</a>
              <span class="hide ng-binding">Data MappingAs in Appbase has the concepts of collections, Documents and Properties, Elasticsearch has Types, Documents, and Fields. Let’s see how Appbase data is indexed and how these concepts are mapped.In a nutshell, All the documents of Appbase are stored as documents inside ES, where the collection of the document becomes its type. Properties of the document can be accessed and filtered as fields inside ES.All the examples in this doc ES concepts (Type, Document and Field), as we will be making direct Elasticsearch DSL query, but the query is explained in context the of data in Appbase, so Appbase concepts (collection, document and Property) are used.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-request-and-response-format" class="ng-binding">REQUEST AND RESPONSE FORMAT</a>
              <span class="hide ng-binding">Request and Response FormatAppbase provides two REST API endpoints for performing search.The 1. searches across multiple collections and has an additional field to specify this in the request body. Both endpoints are compatible with ElasticSearch Query DSL and return results in the same format.Roadmap Note:
We will be adding a search endpoint at the document level that queries on the document and it’s references.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-request-and-response-format-request" class="ng-binding">Request</a>
              <span class="hide ng-binding">RequestA typical request object defines:Elasticsearch provides rich Query DSL (Domain Specific Language) based on JSON to define queries. Queries involving major usecases are covered in this documentation, but if you want to know more about DSL, goto this link.This is a sample request query object, let’s call it body.json:Do not worry about the body of this object for now, we will see how to define it for different use cases in this document.The entire curl request would look like: Note:
The search endpoint here is not on a particular collection, it is on the app. The collections on which the search should apply are defined in the request body.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-request-and-response-format-response" class="ng-binding">Response</a>
              <span class="hide ng-binding">ResponseWe provide an unaltered DSL Response from ES. A typical response includes:Elasticseach sidenote:
The score of a result describes how close it matches the query.Example:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching" class="ng-binding">SEARCHING</a>
              <span class="hide ng-binding">SearchingWe see one by one, what queries apply in which search use cases, how you can combine them, and harness the full power that Elasticsearch provides.In each use case below, it is first described how the data is stored, and what kind of search we are trying to achieve on the data. Let’s start with basic use case.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-simple-match-and-fulltext" class="ng-binding">Simple Match and Fulltext</a>
              <span class="hide ng-binding">Simple Match and FulltextThis is the most basic use case we can think of, where you want to just find out documents which contain a certain term, either as a string or a number.For example, “give me all the..”We can use the term filter or term query for such cases.Elasticseach sidenoteA filter in Elasticsearch says Yes or No for a document. I.E. If the document should be present in the results, or not.
A query also scores the document (counts the relevance with the desired search term - a heavy operation) and results come sorted according to their score.Many filters and queries are similar and can be used interchangeably, but its preferred to use queries only for a full text search based on relevance.They can be used together. I.E. Filters are applied first and then on those results, the query is performed calculating the score. They can also be wrapped inside each other.Read more about them here.For all the users with first name as “Andrew”, The term filter can also be used for other datatypes, for e.g:Another useful query is a match query. It allows to define a string of terms and it will find the documents which contains any of these terms. The more matching terms a document contains, the higher its score and higher it will be in the sorted results.The above search request would find tweets which contains terms “hello” or “world” or both. This behavior can be controlled with operator. Its value defaults to “or”, but we can set to “and” as well.The above search request would find tweets which contains terms “hello” and “world”, both.Elasticseach sidenoteThe equivalent filter for a match query is the terms filter.
Read more about them:
 -  match query documentation
 -  terms filter documentationFor more fine tuned searches, like on the users with first name as “Andrew” and last name as “Garlic”, we have to combine queries/filters. We see that later in this document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-fulltext-fuzzy" class="ng-binding">Fulltext: Fuzzy</a>
              <span class="hide ng-binding">Fulltext: FuzzyA fuzzy search matches with the documents who have the terms matching nearly  the search term.This is very useful for Google-like searches, where there could be some typing mistakes, or the user is not sure what word exactly he is searching for.The simplest way to do a fuzzy query is:The above query would return tweets with the message as “hella” or “hallo” etc.Elasticseach sidenoteThere are number of fuzzy queries in Elasticsearch and a number of ways to control the fuzziness of the term. Plus, you can search on a single or more properties (fields). Take a look at these documentations:
- fuzzy query
- fuzzy-like-this query
- more-like-this query</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-fulltext-autocompletewildcard" class="ng-binding">Fulltext Autocomplete/wildcard</a>
              <span class="hide ng-binding">Fulltext Autocomplete/wildcardWhen you want to search based on few characters (generally a use case in autocomplete search bar), you can use the wildcard search.Here’s an example, you will get all the results which has “laur” anywhere in the text.Elasticseach sidenoteYou can use either * or ? as wildcards. ? stands for a single characters, and * stands for any character length. Checkout the Elasticsearch documentation for more.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-fulltext-fuzzy-and-autocomplete" class="ng-binding">Fulltext: Fuzzy and Autocomplete</a>
              <span class="hide ng-binding">Fulltext: Fuzzy and AutocompleteUsing the bool query, which is explained later in this document, we can combine above two cases into a single query and improve our search results.Example:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-numeric-range" class="ng-binding">Numeric-range</a>
              <span class="hide ng-binding">Numeric-range“Give me all the…”We can use the range filter.Elasticseach sidenoteIt can also perform greater/less or equal  searches. See the range filter documentation for more details.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-geo-spatial" class="ng-binding">Geo spatial</a>
              <span class="hide ng-binding">Geo spatialElasticsearch requires you to store your the geographic location using longitude and latitude, stored as a nested JSON object. Lets say that we are storing restaurants, along with their location. The data of a restaurant would be:As long as the location is stored as above inside a document, we can do tons of geo spatial queries with Elasticsearch.We can use geo distance filter to find documents located within specific distance from a geo point.Find restaurants located within 5km from the point 40, -70.Elasticseach sidenoteYou can define the distance in real world Units like km, miles etc. There many ways the shape (box, polygon etc) and the range of this distance can be customized. Check out these documents for more details:
- Elasticsearch Geo Location tutorial
- geo-distance filter
- geo-distance-range filter
- geo-bounding-box filter
- geo-polygon filter
- geo-shape filter
- geohash-cell filter</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-sorting" class="ng-binding">Sorting</a>
              <span class="hide ng-binding">SortingResults are sorted according to their score by default. We can change this behavior by applying sort parameter in the request.Earlier in the numeric range use case, we searched for products in price range $50 and $100. Let’s sort the results according to their price, and then name.Elasticseach sidenoteYou can specify the order of the sort (asc, desc), you can also sort on multi-valued fields. Geo Location based sort is possible too.
Take a look at the sort documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-aggregation" class="ng-binding">Aggregation</a>
              <span class="hide ng-binding">AggregationThere are types of aggregation supported in Elasticsearch.There wide varieties of aggregations and criteria, based on string-terms, locations, dates, numbers, etc. Take a look at the Aggregation API documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-searching-combining-queriesfilters" class="ng-binding">Combining queries/filters</a>
              <span class="hide ng-binding">Combining queries/filtersCase 1) “Give me all the products which..”Case 2)  “Give me all the products which..”Case 4) Multiple properties, “Give me all the users which..”Let’s take a very complex case,Case 3) “Give me all the products which..”Writing these terms into a programming language like Javascript:For such a case, Elasticsearch provides bool query or bool filter. In a bool query/filter you define the the other kind of queries/filters which should or must be satisfied or, must not be satisfied.A bool query/filter can have three kinds of clauses:Lets write the request to search the mobile phones we described above.Elasticseach sidenoteAs you can see in the example here, we have using bool filters. This way you can combine any kind of queries and filters, you can also combine multiple usecases (like fuzzy and wildcard), and write complex search requests. To know more check out:
- bool query documentation
- bool filter documentation</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v3.0/search/use-cases/#use-cases-next-steps" class="ng-binding">NEXT STEPS</a>
              <span class="hide ng-binding">Next stepsThis document may only be able to give you a headstart on Elasticsearch, and it is impossible to cover every use case and feature provided by Elasticsearch.If you have confusions on any of the use cases covered here, see the additional notes and links provided beside them.To understand the Elasticsearch from the basics to advanced level, the book “Exploring Elasticsearch” by Andrew Cholakian, and Elasticsearch: The Definitive Guide are definitely helpful.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search" class="ng-binding">SEARCHING FOR A BETTER SEARCH?</a>
              <span class="hide ng-binding">Searching for a better Search?Building a good quality full-text search experience for an app is a hard problem if your data resides in traditional RDBMS systems. Even database systems like MongoDB have very nascent support for search, others like DynamoDB offer no support. The hard, real fact is that these systems are not designed with search as a use-case, and one is left with a very rudimentary support like exact search match, or in the worst case scenario, even scanning the DB tables.While there are great tools available for search, like Apache Solr and Elasticsearch, they have two big problems:1. It is not recommended to use ElasticSearch as a primary data store. So you are still stuck with the problem of streaming data from your primary store to a search database like ES.2. The documentation is intimidating. Really, it seems the docs are made for rocket scientists rather than your average app developer!We have thought about the Search problem really hard, and have come up with an elegant solution.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search" class="ng-binding">OUR APPROACH TO SEARCH</a>
              <span class="hide ng-binding">Our Approach to SearchAppbase takes the search problem head-on and indexes all the data that is ever stored in Appbase, allowing searching on all the data and relationships. We provide the ability to do the following kind of queries:1. Full-text search - including simple match queries and fuzzy search queries,2. Numeric-range queries - when you want answers to “Give me all the products that cost between $50 and $100” or “fetch all pages from 5 to 10”,3. Geo spatial queries - ElasticSearch offers a lot of Geo Spatial queries. To name a few, you can compare distances, get a bounding box, determine shape,4. Sort queries - sort queries are more like filters to arrange data returned by one of above queries. You can sort the data using multiple “property” parameters.With Aggregation and Combining queries, the possibilities are endless.Here’s a primer to leverage these powerful search queries broken into three steps.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-1-create-an-app" class="ng-binding">1. Create an App</a>
              <span class="hide ng-binding">1. Create an AppLog into Appbase Dashboard, and create a new app. Once you create an app with a desired name, you should see an app dialog box appear as below.Image 1: App name, credentials, and access controls  We will need the app name and the secret in all our API calls. In this case, these would be my_app9 and 097b2b28b6a13cf2e53b6cecfec42b86. We trust you with our app’s secret!</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-2-put-some-data" class="ng-binding">2. Put some Data</a>
              <span class="hide ng-binding">2. Put some DataAppbase works with JSON data. You can store JSON objects with Appbase directly, they would form Appbase vertices (similar to MongoDB documents, or RDBMS records). We can make search requests on all the vertices, or a set of vertices via a JSON based query format (using ElasticSearch’s DSL).For brevity, let’s suppose we are storing user profiles and would like to later search them by different properties. Here’s how a JSON user object might look: To store this data with Appbase, we will make a PATCH request via REST. You can read more about them in our REST API. Here’s how the request would like in our case:When you copy the above code, be sure to replace the Appbase-Secret header and the app name in the URL to your credentials.Understanding the RequestTo store data, we do a PATCH request.URL: https://api.appbase.io/my_app9/v2/people/laura/~properties, whereHeaders
Headers in this request include the Appbase-Secret value and Content-Type as JSON.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data" class="ng-binding">3. Perform Search on Data</a>
              <span class="hide ng-binding">3. Perform Search on DataNow that we have successfully stored data, let’s perform a full-text search.Before that, just a small setup in the dashboard to enable search. Image 2: Select the “Data Browser” view (3rd option).Image 3: Ensure search is enabled on the “people” namespace.Inside the databrowser view, enable Search. The eye icon should appear green, once the search is enabled.Now we are all set to perform a “search” query. Let’s search for users whose occupation is being a designer.The response that you get from Appbase is an array of JSON objects which match the criteria.Response: There you go! Appbase’s search fetches results which are close to the search term, and you get the following object in response.Understanding the Request To perform a search, we do a POST request.URL: https://api.appbase.io/my_app9/v2/people/~search, whereRequest Headers
Headers are always the same for all REST API requests.Request Body
The JSON query object that we send with this request:That’s it! In less than 10 minutes, we were able to add production grade search in your app.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/quick-start/#searching-for-a-better-search-next-steps" class="ng-binding">NEXT STEPS</a>
              <span class="hide ng-binding">Next StepsDo you want to customize the ‘fuzziness’ of your search? Or perhaps apply multiple queries and filter the data at the same time. If this has whetted your appetite, check out our main “search” course on the ElasticSearch documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase" class="ng-binding">STEPS TO GETTING STARTED WITH APPBASE</a>
              <span class="hide ng-binding">Steps to getting started with Appbase</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-0-get-appbase" class="ng-binding">STEP 0: GET APPBASE</a>
              <span class="hide ng-binding">Step 0: Get AppbaseLog in to  Appbase Dashboard, and create a new app.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-1-add-the-appbase-js-library" class="ng-binding">STEP 1: ADD THE APPBASE JS LIBRARY</a>
              <span class="hide ng-binding">Step 1: Add the Appbase JS LibraryAdd Appbase library to your codebase and set the app credentials as they appear here.Note: You will want to change the parameters of the Appbase.credentials() method to your own app name, app secret combination, as seen in the Dashboard.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-2-creating-vertices" class="ng-binding">STEP 2: CREATING VERTICES</a>
              <span class="hide ng-binding">Step 2: Creating VerticesNow let’s create two Appbase vertices under two different namespaces “user” and “tweets”.Namespaces are containers that do not hold actual data, but help with data logic separation. A “vertex” can only be created using a ns reference object.As seen here, vertex takes a “String” as an identifier. Appbase.uuid() is a handy way for creating a unique String id.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-3-storing-some-data" class="ng-binding">STEP 3: STORING SOME DATA</a>
              <span class="hide ng-binding">Step 3: Storing some DataA vertex can store data as a JSON object using the setData() method.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-4-creating-a-simple-data-model" class="ng-binding">STEP 4: CREATING A SIMPLE DATA MODEL</a>
              <span class="hide ng-binding">Step 4: Creating a simple data modelVertices can be connected via edges. Now let’s add the tweetRef as an edge to the userRef vertex.Now, the tweetRef vertex can also be accessed using the path /user/andy/tweeted. To retrieve a vertex reference at a given path, ns.v(path) is a handy method.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-5-retrieving-data-in-real-time" class="ng-binding">STEP 5: RETRIEVING DATA, IN REAL-TIME!</a>
              <span class="hide ng-binding">Step 5: Retrieving data, in real-time!Appbase supports retrieval of objects using realtime streams. We will now add listeners, which return existing data stored, and keeps returning new data as it keeps changing. Similarly we will add a listener for retrieving edges on the vertex.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-6-smart-search" class="ng-binding">STEP 6: SMART SEARCH</a>
              <span class="hide ng-binding">Step 6: Smart searchAppbase supports a full-text smart search, and you can enable it in two simple steps.Enable the search by toggling the  switch in your app’s preferred namespace. If search is enabled, you should see this icon  next to the namespace.
Second and final step, use this code snippet on the enabled namespace and have a full-text search widget.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-further" class="ng-binding">FURTHER</a>
              <span class="hide ng-binding">FurtherIf you are using Appbase from a Javascript client, you might want to use user authentications over secret. Checkout here for more.As a next step, you should checkout the Javascript API reference for an in-depth usage guide.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication" class="ng-binding">USER AUTHENTICATION</a>
              <span class="hide ng-binding">User AuthenticationMost applications need to know the identity of a user. Knowing a user’s identity allows an app to provide a customized experience. The process of proving a user’s identity is called authentication.Appbase makes authentication easy with completely client-side code. It has built-in functionality for third-party providers such as Facebook, LinkedIn, GitHub, Dropbox, and Google.When a user authenticates to an Appbase app, the information about the user is returned in callbacks on the client device. This allows you to customize your app’s user experience for that specific user. Appbase also issues a requestObject, which makes it easy for you to access the providers’ data APIs.Once a user authenticates to your app, Appbase manages their session, ensuring that the user is remembered across page refreshes and browser restarts.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-configuring-login" class="ng-binding">CONFIGURING LOGIN</a>
              <span class="hide ng-binding">Configuring LoginFor security reasons, only domains that you whitelist are allowed to initiate authentication for your app.  All Appbase apps have localhost and 127.0.0.1 enabled by default for local development and testing. Add more authorized origins to enable authentication from domains where your host your app.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-enabling-providers" class="ng-binding">ENABLING PROVIDERS</a>
              <span class="hide ng-binding">Enabling ProvidersNext, you need to enable the provider that you selected for your Appbase.Appbase is all set up for your provider. It’s time to code.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-logging-user-in" class="ng-binding">LOGGING USER IN</a>
              <span class="hide ng-binding">Logging User InThe following code shows a popup and retrieves the user’s credentials for Appbase, and Facebook.Appbase automatically retrieves the basic information about the user (the me data) from the provider, the access tokens for Appbase and the provider and present it as the authObj.
authObj is a JSON object:Appbase stores and uses these tokens for accessing appbase REST api, and provider’s data APIs.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-accessing-providers-data-apis" class="ng-binding">ACCESSING PROVIDER’S DATA APIS</a>
              <span class="hide ng-binding">Accessing provider’s data APIsrequestObj returned in the authentication can be used to you to perform API calls to a provider. It contains methods that wrap the usual HTTP methods: .get(), .post(), .put(), .patch(), and .del().</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-caching-credentials" class="ng-binding">CACHING CREDENTIALS</a>
              <span class="hide ng-binding">Caching CredentialsOnce the user logs in with a provider, the credentials are cached in localStorage automatically, and this helps staying logged in across browser restarts. To fetch these cached credentails call, Appbase.getAuth().getAuth() saves you from calling authPopup() again for authenticating user when the user already went through the login flow previously. It returns the two objects described object: authObj and requestObj. If user is not authenticated, it returns null.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-dealing-with-popups-and-redirects" class="ng-binding">DEALING WITH POPUPS AND REDIRECTS</a>
              <span class="hide ng-binding">Dealing with Popups and RedirectsAppbase supports two different ways to authenticate with OAuth providers - via pop-up, or browser redirect.Third-party authentication methods use a browser pop-up window, or browser redirect, to prompt the user to sign-in, approve the application, and return the user’s data to the requesting application.Most modern browsers block pop-up windows unless they are invoked by direct user action. Therefore, we should only invoke the authPopup() method for third-party authentication upon the user’s click, otherwise authRedirect() should be used.authRedirect() redirects to the provider’s login page, where the user can accept your app’s permissions. Once he has, he is redirected to the callback url.After this call, at the page where the redirect URL points, call authCallback(), which allows you to retrieve the credentials.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-working-with-scopes-and-additional-parameters" class="ng-binding">WORKING WITH SCOPES, AND ADDITIONAL PARAMETERS</a>
              <span class="hide ng-binding">Working with Scopes, and additional parametersProviders require different scope parameters, to access the user’s data on their APIs. 
For eg. Providers might even require additional parameters, which can be defined in the options to Appbase.authPopup() ,along with the scope:Findout the different configurations, scopes and code samples for all the providers here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-logging-users-out" class="ng-binding">LOGGING USERS OUT</a>
              <span class="hide ng-binding">Logging Users OutThis will remove the credentials from memory and all the requests to Appbase server and, and provider’s API will fail.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#user-authentication-code-samples" class="ng-binding">CODE SAMPLES</a>
              <span class="hide ng-binding">Code SamplesFindout code samples for all the providers here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide" class="ng-binding">AUTHENTICATION - ADDITIONAL GUIDE</a>
              <span class="hide ng-binding">Authentication - additional guideEvery provider requires Oauth paramters to be passed while authenticating. Mostly, they are the same across all providers, for eg. redirect_url, token_type, client_id etc. Appbase takes care of these paramters, except for some cases, which depends on the developer’s need. This document explains how to provide these paramters while authenticating with Appbase and a provider, plus provides links to provider’s additional documentation.You can directly use the code snippets given here for a provider, and the authentication will work out of the box.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-scopes" class="ng-binding">SCOPES</a>
              <span class="hide ng-binding">ScopesScoping allows OAuth clients to tell an authorization server what permissions they’ll need on resources they’re accessing. The required scopes, can be specified while calling Appbase.authPopup(), and then we can access the data using requestObject, and calling provider’s data endpoints.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-google" class="ng-binding">GOOGLE</a>
              <span class="hide ng-binding">Google</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-google-required-paramters" class="ng-binding">Required paramters</a>
              <span class="hide ng-binding">Required paramters</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-google-minimal-code" class="ng-binding">Minimal Code</a>
              <span class="hide ng-binding">Minimal Code</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-google-additional-docs" class="ng-binding">Additional docs</a>
              <span class="hide ng-binding">Additional docsFind out more about scopes and API endpoints supported by Google here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-google-calling-apis" class="ng-binding">Calling APIs</a>
              <span class="hide ng-binding">Calling APIs</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-facebook" class="ng-binding">FACEBOOK</a>
              <span class="hide ng-binding">Facebook</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-facebook-minimal-code" class="ng-binding">Minimal Code</a>
              <span class="hide ng-binding">Minimal Code</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-facebook-additional-docs" class="ng-binding">Additional docs</a>
              <span class="hide ng-binding">Additional docsFind out more about scopes and API endpoints supported by Facebook here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin" class="ng-binding">LINKEDIN</a>
              <span class="hide ng-binding">LinkedIn</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin-minimal-code" class="ng-binding">Minimal Code</a>
              <span class="hide ng-binding">Minimal Code</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin-additional-docs" class="ng-binding">Additional docs</a>
              <span class="hide ng-binding">Additional docsFind out more about scopes and API endpoints supported by LinkedIn here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-github" class="ng-binding">GITHUB</a>
              <span class="hide ng-binding">Github</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-github-minimal-code" class="ng-binding">Minimal Code</a>
              <span class="hide ng-binding">Minimal Code</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-github-additional-docs" class="ng-binding">Additional docs</a>
              <span class="hide ng-binding">Additional docsFind out more about scopes and API endpoints supported by Github here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox" class="ng-binding">DROPBOX</a>
              <span class="hide ng-binding">Dropbox</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox-minimal-code" class="ng-binding">Minimal Code</a>
              <span class="hide ng-binding">Minimal Code</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox-additional-docs" class="ng-binding">Additional docs</a>
              <span class="hide ng-binding">Additional docsFind out more about API endpoints supported by Dropbox here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide" class="ng-binding">NG-APPBASE GUIDE</a>
              <span class="hide ng-binding">ng-Appbase GuideAppbase provides a realtime graph backend, is designed to write complex applications completely clientside. Appbase fits perfectly as a backend in your AngularJS application.ngAppbase - AngularJS binding for Appbase, makes it very simple to bind your data between AngularJS and Appbase backend.Here‘s a quick tutorial for Appbase JS api.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-integrating-the-awesome" class="ng-binding">INTEGRATING THE AWESOME</a>
              <span class="hide ng-binding">Integrating the awesomeAdd these script tags in your HTML:Register ngAppbase as a dependency in the module, and the $appbase is available to be injected into any controller, service, or factory.$appbase, has the same methods as Appbase object exposed by the Appbase Javascript library. The difference is, when Appbase refrences (namespace and vertex) are created using $appbase, they have extra methods which allows binding your data with scope variables in Angular.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-binding-objects" class="ng-binding">BINDING OBJECTS</a>
              <span class="hide ng-binding">Binding ObjectsAs Angular binds the data between JS models and the DOM, ngAppbase propagates any changes the data from Appbase. This way, any changes to Appbase automatically appears in the DOM.
Notice that, the changes in the JS model are not automatically sent to Appbase backend.bindProperties creates such a synchronized object, by binding properties of a vertex in Appbase, to a variable in JS.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-binding-objects-example" class="ng-binding">Example:</a>
              <span class="hide ng-binding">Example:Assume the properties of the vertex at ‘user/bella’ : To bind this data to your view,
JS:HTML:As Appbase notifies for data changes in realtime, if the data at ‘user/bella’ changes, i.e. if $appbase.ns('user').v('bella').setData({having: 'Cerveja'}) is called, this change will be reflected in the scope variable instantly, and Angular will update the view.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-binding-arrays" class="ng-binding">BINDING ARRAYS</a>
              <span class="hide ng-binding">Binding Arraysng-repeat in AngularJS binds a list in DOM to an array model in JS, and this array can be bound to the edges of a vertex, or vertices in a namespace in Appbase, using bindEdges and bindVertices.When edges or vertices are added, removed, replaced, or the priority is changed, these changes appear in the DOM in realtime.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-binding-arrays-example" class="ng-binding">Example</a>
              <span class="hide ng-binding">ExampleData in the out vertex pointed by the edge:To bind this data into you view:
JS:HTML:The same way, you can bind vertices under a namespace, as an array.JS:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-modifying-data" class="ng-binding">MODIFYING DATA</a>
              <span class="hide ng-binding">Modifying dataVertex References created with $appbase.ns().v() has all the methods exactly as the Appbase Javascript API. You can use methods setData() and setEdge() to modify the data.The  documentation for Appbase JS api is here.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#ng-appbase-guide-next-steps" class="ng-binding">NEXT STEPS</a>
              <span class="hide ng-binding">Next StepsCheckout additional documentation for bindEdges(), bindVertices() and bindProperties() further down on this page.Checkout this opensource Twitter clone we built using this Angular binding in under ~250 lines of javascript code.Have a great time building awesome realtime applications!</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs" class="ng-binding">$APPBASE API DOCS</a>
              <span class="hide ng-binding">$appbase API Docs</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges" class="ng-binding">VERTEXREF.BINDEDGES()</a>
              <span class="hide ng-binding">vertexRef.bindEdges()</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges-returns" class="ng-binding">Returns</a>
              <span class="hide ng-binding">ReturnsAn array of edges, sorted by the priority of edges.
Each object (called edgeData from now on) in array represents an edge and contains this data:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges-arguments" class="ng-binding">Arguments</a>
              <span class="hide ng-binding">ArgumentsNote that the vertex references returned in the callback, also have the methods bindProperties and bindEdges. Using onAdd callback and these methods, you can bind multiple level of edges.Eg.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-bindvertices" class="ng-binding">BINDVERTICES()</a>
              <span class="hide ng-binding">bindVertices()bindVertices works exactly as bindEdges, except that it is invoked on a namespace reference and returns an array of all the vertices in the namespace. Callbacks onAdd, onRemove and onChange are called, respectively, when a vertex is added, destroyed and properties are changed. onComplete is called when existing vertices are retrieved. Works exactly as onComplete callback for vertex_added event in Appbase Javascript Library.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-bindproperties" class="ng-binding">BINDPROPERTIES()</a>
              <span class="hide ng-binding">bindProperties()</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-bindproperties-returns" class="ng-binding">Returns</a>
              <span class="hide ng-binding">ReturnsAn object , containing properties of the vertex as key-value pairs.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/angular/#appbase-api-docs-bindproperties-arguments" class="ng-binding">Arguments</a>
              <span class="hide ng-binding">Arguments</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel" class="ng-binding">DATAMODEL</a>
              <span class="hide ng-binding">DatamodelAppbase is a realtime Database as a Service (DBaaS), built on top of a graph schema with JSON based vertices (similar to JSON documents), and edges to link them.All databases support the storing and fetching of data, what distinguishes one database type from another is the structure of the data they store and the means by which it can be retrieved. Several popular databases can be classified as below:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-data-in-appbase" class="ng-binding">DATA IN APPBASE</a>
              <span class="hide ng-binding">Data in AppbaseAppbase is a Directed Graph. Objects inside Appbase are called Vertices) (a graph term for entities), and the links (relationships) between the objects are called Edges.Data in Appbase is stored as JSON objects. Appbase supports flexible schema, i.e. the properties of the JSON object need not be defined in advance. Although Appbase supports storing embedded JSON objects and arrays, one doesn’t have to store data in this denormalized fashion. This is mainly for compatibility with existing document stores like MongoDB. The recommended approach is to create reference links between distint entities. In this doc, we will cover how you can store different kinds data (primitive values, objects, lists), create relationships amongst them, normalize, and do perform different queries on them.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts" class="ng-binding">CONCEPTS</a>
              <span class="hide ng-binding">ConceptsSimilar to how SQL has concepts for table, row, column, relation and MongoDB has collection , Document and fields, here are the key concepts in Appbase.Vertex — is similar to a Document in MongoDB, it stores data.  Namespace — is similar to a Collection in MongoDB or type in ElasticSearch. A vertex always belongs to a namespace and security rules can be applied on namespaces. Edge — is a directional link to another vertex.  i.e. an edge is pointed from inVertex to an outVertex.Path — Every vertex in Appbase has a path, starting from the &amp;lt;namespace&amp;gt; and ending at the vertex, not unlike the UNIX path. A typical path looks like &amp;lt;namespace&amp;gt;/&amp;lt;v1&amp;gt;/&amp;lt;v2&amp;gt;/…/&amp;lt;vn&amp;gt;/.URL — It is a way to point to a Path in the REST API. Paths are prefixed with the Appbase API base URL, application’s name and the API version. Eg. https://api.appbase.io/chat_app/v2/&amp;lt;path&amp;gt;/.We can not actually compare these concepts with other kinds of databases, but it helps to understand Appbase if we compare the usage practices.With this table in mind, lets understand how the concepts work.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts-vertex" class="ng-binding">Vertex</a>
              <span class="hide ng-binding">VertexVertex is the the standard data container in Appbase. A vertex can store a valid JSON object and be linked to other vertices via edges.It can also store nested JSON objects and arrays, but this is only for convenience. In practice, vertices act as singular data entities, i.e. you store only the data relevant to a single entity in the real world. For e.g. a person’s age, name, height, sex can be stored in a single vertex, but the data of his belongings, like a book or a car is a completely different entity. This new entity will have properties of its own and they should be stored inside a new vertex. Later in this document, we will see how we can create a relation between these two entities.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts-namespace" class="ng-binding">Namespace</a>
              <span class="hide ng-binding">NamespaceNamespaces are a way to combine similar entities. For eg. all vertices storing different users can be stored inside the user namespace and all the tweets (repreented as vertices) can be stored inside the tweet namespace. Since namespace is a logical container, different kinds of objects can be stored inside a single namespace. This allows searching for similar vertices and applying security rules with ease.Namespaces are searchable. We are using the open-source ElasticSearch behind the scenes to support this use-case. See this documentation for a quick intro on how search works.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts-edge-one-to-one-relationships" class="ng-binding">Edge (one-to-one relationships)</a>
              <span class="hide ng-binding">Edge (one-to-one relationships)After creating entities, its time to create relations amongst them via edges. An edge is a named directional link connecting two vertices for a purpose, a one-to-one relation. For instance, a book has an author, a husband has wife and a child has a mother. The edges for these would be book vertex --authouredBy-&amp;gt; person vertex, man vertex --marriedTo-&amp;gt; woman vertex. Edges are directional, so if you set the edge man --marriedTo-&amp;gt; woman, it only tells us that the man is married to the woman, but it tells us nothing about woman’s relationship status. For that, another edge, woman --marriedTo-&amp;gt; man, should be created.Appbase only allows for unique edge names. The default behaviour is last-write-wins in case a new edge is created with an existing name. Edges have priorities which are rational numbers (think of the Number datatype in Javascript).</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts-path" class="ng-binding">Path</a>
              <span class="hide ng-binding">PathPaths are the way to interact with vertices in Appbase. Paths are constructed with &amp;lt;namespace&amp;gt;/&amp;lt;vertexKey&amp;gt;/&amp;lt;edgeName_1&amp;gt;/…/&amp;lt;edgeName_N&amp;gt;/.Creating edges create deeper Paths. Lets take the example of the movie Inception, the Oscar deserver lead actor Leonardo DiCaprio, and the director Christopher Nolan. Here are the vertices stored in Appbase:These vertices can be accessed with the following paths, as entry points in the graph:Let’s create edges:With these edge, we created these deeper paths:movie/inception/leadActor : points to the same vertex as person/dicapriomovie/inception/directedBy : points to person/nolanperson/nolan/marriedTo: points to person/emmaHere’s the magic, the path movie/inception/directedBy/marriedTo points directly to person/emmaThis means, modifying the data stored at movie/inception/directedBy/marriedTo will change the data of person/emma as they both are the same vertices.Paths are powerful ways to point to the exact data you want to interact with. For e.g.  when you access the path movie/inception/directedBy/marriedTo, you are only interested in the vertex representing the person who is married to the director of Inception, and nothing else. You never access the data of the movie Inception, or the director.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-concepts-url" class="ng-binding">URL</a>
              <span class="hide ng-binding">URLA URL is just another representation of a Path. REST API URL looks like this: https://api.appbase.io/&amp;lt;app_name&amp;gt;/v2/&amp;lt;path&amp;gt;/. Assuming the Application’s name as imdb, URL for the path movie/inception/directedBy/marriedTo would be https://api.appbase.io/imdb/v2/movie/inception/directedBy/marriedTo</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-storing-data" class="ng-binding">STORING DATA</a>
              <span class="hide ng-binding">Storing DataBeing a Graph, Appbase allows you to create any kind of data structures you want, you just need to know exactly how. Lets see how to store the practical data structures we used on daily basis.The examples here use Appbase Javascript Library and if any of the method is confusing you, feel free to chekout the JS Documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-storing-data-primitive-data-and-json-objects" class="ng-binding">Primitive Data and JSON Objects</a>
              <span class="hide ng-binding">Primitive Data and JSON ObjectsNumbers, Characters, Strings and Booleans, are stored as values of the properties inside a vertex. Dates can be converted into the milliseconds since epoch, and store them as Numbers. For eg. you want to store a the movie’s name, and its release year, you can store combine all of them as a JSON object and store it inside a vertex.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-storing-data-nested-json-objects" class="ng-binding">Nested JSON Objects</a>
              <span class="hide ng-binding">Nested JSON ObjectsYou can store nested objects directly inside a vertex. E.g.This would work perfectly. Notice that you are not storing the director (Nolan) of Inception as a different entity, instead as a property of the movie itself. While this approach is sometimes handy, it limits you in terms of what you can do with Nolan. I.e. you will not be able to establish any direct relationships with Nolan, as it is not an entity in itself. For eg. Nolan is married to Emma, but there is no way to create a link between Nolan  and Emma, when it is stored as a nested object in Appbase.A better to do this is store Nolan as a new vertex, and create an edge from Inception to Nolan. You can create another vertex for Emma create edges with Nolan. We will create three edges here: inception --directedBy-&amp;gt; nolannolan --marriedTo-&amp;gt; emma
Recall that the edges are directional, so this 2nd edge only tells us that Nolan in married to Emma, but says nothing about Emma’s marital status. That’s why we create the third edge: emma --marriedTo-&amp;gt; nolanNotice that Inception directed by Nolan, is a One-to-One relationship. Nolan has directed many movies, and that’s a case of One-to-Many relationships. We see later how to create them in Appbase. </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-storing-data-sets-one-to-many-relationship" class="ng-binding">Sets (One-to-Many Relationship)</a>
              <span class="hide ng-binding">Sets (One-to-Many Relationship)A set makes sure that all the items in the list exist only once. Consider this example, the movies directed by Nolan. We will make only a small list here:  ["Interstellar", "Inception", "The Dark Night", "Memento"]. Clearly, it doesn’t make sense to have any of the movies twice in the this list.  Notice that this is a One-to-Many relationship here. Nolan (1) -&amp;gt; Movies (N).Operations on a single set are: addition, checking existence of an item, deletion and traversal. Operations on multiple sets, like union and intersection can be emulated using single-set operations. For e.g.Let’s see a practical set, the movies directed by Nolan. In Appbase, the Set is a vertex, let’s create it.Also the Items in the set are vertices.Now we have Appbase Vertex References to the Set and the Items, lets go through different set operations.Simply creating an edge from the Set to the Item. We will use the Primary Key (inceptionRef.name()) of the item as the name of the edge.Here, the important thing is to keep the edge-name exactly as the Vertex Key. That way makes sure that every item will exist only once in the set. For e.g. if you try to add inceptionRef again in the set, it will just replace the old edge no extra edges will be created.Keeping the edge-name same as the Vertex Key of the item, allows other operations as well, like deletion of an Item and checking where an Item exists.Remove the edge from Set to the Item.As we kept the edge name exactly as the Vertex Key, it means that we can use the Vertex Key to delete the edge as well.It’s not possible to check via the Item’s data, if the item exists or not. The only way we can check, is using the Vertex Key/edge-name. We see that if there’s an edge, with its name as the Vertex Key. We use outVertex() and isValid() for that. I.e. we are checking if the path set/moviesByNolan/&amp;lt;movieVertexKey&amp;gt; is valid or not.As all the items are the edges of the Set vertex, we simply fetch the edges of the Set vertex, and traverse through them.See Retrieving Data section.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-retrieving-data" class="ng-binding">RETRIEVING DATA</a>
              <span class="hide ng-binding">Retrieving DataIn a nutshell, Namspaces in Appbase have vertices, and vertices have properties, edges.Data retrieval in Appbase happens via realtime streams. These streams allows you to fetch existing data, and then keep listening to new data as well.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-retrieving-data-properties" class="ng-binding">Properties</a>
              <span class="hide ng-binding">PropertiesWhen you start listening to the properties of a vertex, you first get the existing properties, and then as the data keeps changing, the callback is called again with new properties.Appbase gives you the properties data as a snapshot. The snapshots are immutable copies of the data stored in a vertex. Any changes you make in the snapshot will not be stored in Appbase. If you don’t want to listen to the properties any more, you can turn the listener off with inceptionRef.off().For convenience, we have the method  inceptionRef.once() when you want to listen to daat just only once.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-retrieving-data-edges" class="ng-binding">Edges</a>
              <span class="hide ng-binding">EdgesRetrieving existing edges of a vertex is simple: just listen to edge_added event, which will return existing edges at first. When new edges are added, the callback will be fired for new edges as well.Notice that the if there are ‘N’ number of existing edges, the callback will be called ‘N’ times.eRef here is the Appbase Reference to the outVertex, and eSnap is the snapshot of the edge. Edge Snapshot is the snapshot of the data stored with the edge and the out vertex, mainly the priority of the edge, and the properties of the out vertex. eSnap.priority() will give you the priority, and eSnap.properties() will give you properties.With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them, or want to fetch only a particular edge.When more than one filter is provided, they work as logical AND and only the edges matchihg all filters will be fetched. This is what each filter means:Notice that:
 - Filters are a way to fetch existing edges, thus they work only with edge_added event
 - Edges are always returned ordered according to their priorities
 - When endAt &amp;lt; startAt, edges are returned in reverse order
 - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime
    - This means that the numeric filters can not be used with onlyNew set to be true
    - Newly created edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/concepts/datamodel/#datamodel-retrieving-data-vertices-in-a-namespace" class="ng-binding">Vertices in a Namespace</a>
              <span class="hide ng-binding">Vertices in a NamespaceNamespaces are vertex containers, and it is possible to retrieve existing vertices, and listen to updates when new vertices are added or old vertices are removed.The callback attached with vertex_added event is called for all the existing vertices. As new vertices are added, it is called for them too.To listen to updates of vertex removal, use vertex_removed event.With ElasticSearch’s powerful APIs in the backend, Appbase supports full-text fuzzy search queries on the data stored into vertices of a namespace. A sample query on a namespace looks something like this: This query searches on all the vertices of the namespace movie, and returns an array of vertices who’s property year, matches fuzzily with the text “2010”. See this documentation for more details.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases" class="ng-binding">USE-CASES</a>
              <span class="hide ng-binding">Use-casesAppbase uses opensource Elasticsearch in the backend, and provides all the powerful search features of ES, on the data stored in Appbase.When you want to make some data searchable, you have to enable search on a namespace in the Dashboard. In the Data Browser, enable the search by toggling the  switch on the namespace. If search is enabled, you should see this icon  next to the namespace. Enabling search on a namespace causes all the vertices inside the namespace to be indexed inside Elasticsearch. New vertices created inside this namespace are automatically indexed, and searchable. When the data of a vertex is updated, the indices update automatically and new data is searchable.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-elasticsearch-introduction" class="ng-binding">ELASTICSEARCH INTRODUCTION</a>
              <span class="hide ng-binding">Elasticsearch IntroductionElasticSearch is powered by Lucene, a powerful open-source full-text search library, under the hood. More than just full-text queries, ES can be used for numeric range queries, geo spatial queries, aggregation/ordering/grouping search results etc. In addition, we can combine these queries (logical and/or) and search across multiple namespaces and properties. To learn more about Elasticsearch, checkout this very effective guide.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-data-mapping" class="ng-binding">DATA MAPPING</a>
              <span class="hide ng-binding">Data MappingAs in Appbase has the concepts of Namespaces, Vertices and Properties, Elasticsearch has Types, Documents, and Fields. Let’s see how Appbase data is indexed and how these concepts are mapped.In a nutshell, All the vertices of Appbase are stored as documents inside ES, where the namespace of the vertex becomes its type. Properties of the vertex can be accessed and filtered as fields inside ES. All the examples in this doc ES concepts (Type, Document and Field), as we will be making direct Elasticsearch DSL query, but the query is explained in context the of data in Appbase, so Appbase concepts (Namespace, Vertex and Property) are used.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-request-and-response-format" class="ng-binding">REQUEST AND RESPONSE FORMAT</a>
              <span class="hide ng-binding">Request and Response FormatTo do a raw ES query on the data, Appbase provides a REST API endpoint and the Javascript library method Appbase.rawSearch(). Both of them, accepts similar request Query Object, and gives similar responses. </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-request-and-response-format-request" class="ng-binding">Request</a>
              <span class="hide ng-binding">RequestA typical request object defines:Elasticsearch provides rich Query DSL (Domain Specific Language) based on JSON to define queries. Queries involving major usecases are covered in this documentation, but if you want to know more about DSL, goto this link.This is a sample request Query Object: Do not worry about the body of this object for now, we will see how to define it for different use cases in this document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-request-and-response-format-response" class="ng-binding">Response</a>
              <span class="hide ng-binding">ResponseWe provide an unaltered DSL Response from ES. A typical response includes:Elasticseach sidenote
The score of a result describes how close it matches the query.Example: </span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching" class="ng-binding">SEARCHING</a>
              <span class="hide ng-binding">SearchingWe see one by one, what queries apply in which search use cases, how you can combine them, and harness the full power that Elasticsearch provides. In each use case below, it is first described how the data is stored, and what kind of search we are trying to achieve on the data. Let’s start with basic use case.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-simple-match" class="ng-binding">Simple Match</a>
              <span class="hide ng-binding">Simple MatchThis is the most basic use case we can think of, where you want to just find out vertices which contain a certain term, either as a string or a number. For example, “give me all the..”We can use the term filter or term query for such cases.Elasticseach sidenoteA filter in Elasticsearch says Yes or No for a document. I.E. If the document should be present in the results, or not. 
A query also scores the document (counts the relevance with the desired search term - a heavy operation) and results come sorted according to their score.Many filters and queries are similar and can be used interchangeably, but its preferred to use queries only for a full text search based on relevance.They can be used together. I.E. Filters are applied first and then on those results, the query is performed calculating the score. They can also be wrapped inside each other. Read more about them here.For all the users with first name as “Andrew”, The term filter can also be used for other datatypes, for e.g:Another useful query is a match query. It allows to define a string of terms and it will find the documents which contains any of these terms. The more matching terms a vertex contains, the higher its score and higher it will be in the sorted results.The above search request would find tweets which contains terms “hello” or “world” or both. This behavior can be controlled with operator. Its value defaults to “or”, but we can set to “and” as well. The above search request would find tweets which contains terms “hello” and “world”, both.Elasticseach sidenoteThe equivalent filter for a match query is the terms filter.
Read more about them: 
 -  match query documentation
 -  terms filter documentationThe multi_match query can search on multiple fields (properties) and returned if any of those properties match any of the terms.The below query would search for users with either first name or last name, being “Andrew” or “Garlic”. I.E. also the users with first name as “Garlic” would be included, and vice versa.For more fine tuned searches, like on the users with first name as “Andrew” and last name as “Garlic”, we have to combine queries/filters. We see that later in this document.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-fuzzy" class="ng-binding">Fuzzy</a>
              <span class="hide ng-binding">FuzzyA fuzzy search matches with the documents who have the terms matching nearly  the search term.This is very useful for Google-like searches, where there could be some typing mistakes, or the user is not sure what word exactly he is searching for. The simplest way to do a fuzzy query is:The above query would return tweets with the message as “hella” or “hallo” etc. Elasticseach sidenoteThere are number of fuzzy queries in Elasticsearch and a number of ways to control the fuzziness of the term. Plus, you can search on a single or more properties (fields). Take a look at these documentations:
- fuzzy query
- fuzzy-like-this query
- more-like-this query</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-numeric-range" class="ng-binding">Numeric-range</a>
              <span class="hide ng-binding">Numeric-range“Give me all the…”We can use the range filter.Elasticseach sidenoteIt can also perform greater/less or equal  searches. See the range filter documentation for more details.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-geo-spatial" class="ng-binding">Geo spatial</a>
              <span class="hide ng-binding">Geo spatialElasticsearch requires you to store your the geographic location using longitude and latitude, stored as a nested JSON object. Lets say that we are storing restaurants, along with their location. The data of a restaurant would be: As long as the location is stored as above inside a vertex, we can do tons of geo spatial queries with Elasticsearch.We can use geo distance filter to find vertices located within specific distance from a geo point.Find restaurants located within 5km from the point 40, -70.Elasticseach sidenoteYou can define the distance in real world Units like km, miles etc. There many ways the shape (box, polygon etc) and the range of this distance can be customized. Check out these documents for more details: 
- Elasticsearch Geo Location tutorial
- geo-distance filter
- geo-distance-range filter
- geo-bounding-box filter
- geo-polygon filter
- geo-shape filter
- geohash-cell filter</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-sorting" class="ng-binding">Sorting</a>
              <span class="hide ng-binding">SortingResults are sorted according to their score by default. We can change this behavior by applying sort parameter in the request.Earlier in the numeric range use case, we searched for products in price range $50 and $100. Let’s sort the results according to their price, and then name.Elasticseach sidenoteYou can specify the order of the sort (asc, desc), you can also sort on multi-valued fields. Geo Location based sort is possible too.
Take a look at the sort documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-aggregation" class="ng-binding">Aggregation</a>
              <span class="hide ng-binding">AggregationThere are types of aggregation supported in Elasticsearch. There wide varieties of aggregations and criteria, based on string-terms, locations, dates, numbers, etc. Take a look at the Aggregation API documentation.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-searching-combining-queriesfilters" class="ng-binding">Combining queries/filters</a>
              <span class="hide ng-binding">Combining queries/filters“Give me all the products which..”Writing these terms into a programming language like Javascript: For such a case, Elasticsearch provides bool query or bool filter. In a bool query/filter you define the the other kind of queries/filters which should or must be satisfied or, must not be satisfied.A bool query/filter can have three kinds of clauses:Lets write the request to search the mobile phones we described above.Elasticseach sidenoteAs you can see in the example here, we have using bool filters. This way you can write really complex search requests. To know more check out:
- bool query documentation
- bool filter documentation</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/search/use-cases/#use-cases-next-steps" class="ng-binding">NEXT STEPS</a>
              <span class="hide ng-binding">Next stepsThis document may only be able to give you a headstart on Elasticsearch, and it is impossible to cover every use case and feature provided by Elasticsearch. If you have confusions on any of the use cases covered here, see the additional notes and links provided beside them.To understand the Elasticsearch from the basics to advanced level, the book “Exploring Elasticsearch” by Andrew Cholakian, and Elasticsearch: The Definitive Guide are definitely helpful.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#introduction" class="ng-binding">INTRODUCTION</a>
              <span class="hide ng-binding">IntroductionThe Appbase JS library allows developers to create realtime multi-user apps using a graph data model and realtime smart-search capabilities.To use it in the browser, use this link: https://cdn.appbase.io/latest/appbase.jsTo use it with nodejs, do npm install appbasejsThe Appbase library exposes the Appbase object. The methods in the JS lib rely on three main objects.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase" class="ng-binding">APPBASE</a>
              <span class="hide ng-binding">AppbaseAppbase is the global object exposed the JS library. It has the following four methods: credentials(), 
ns(), uuid(), and serverTime().</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-setting-up" class="ng-binding">SETTING UP</a>
              <span class="hide ng-binding">Setting up</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-setting-up-credentials" class="ng-binding">credentials()</a>
              <span class="hide ng-binding">credentials()Authorize the app credentials using the appname and appsecret identifiers, as they appear in the Dev Console.UsageAppbase.credentials(appname, [appsecret , onComplete])onComplete Function — will be passed two arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-namespaces" class="ng-binding">NAMESPACES</a>
              <span class="hide ng-binding">Namespaces</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-namespaces-ns" class="ng-binding">ns()</a>
              <span class="hide ng-binding">ns()Get the namespace reference with the passed string identifier. It creates a new namespace if one doesn’t already exist, else returns reference to the existing namespace. See Namespace Reference docs for how namespaces work.UsageAppbase.ns(namespace)ReturnsObject nsref Namespace Reference</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-fantastic-search" class="ng-binding">FANTASTIC SEARCH</a>
              <span class="hide ng-binding">Fantastic Search</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-fantastic-search-rawsearch" class="ng-binding">rawSearch()</a>
              <span class="hide ng-binding">rawSearch()Appbase uses ElasticSearch in the backend. To completely understand how it works, please refer to this page.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-utility" class="ng-binding">UTILITY</a>
              <span class="hide ng-binding">Utility</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-utility-uuid" class="ng-binding">uuid()</a>
              <span class="hide ng-binding">uuid()Returns a 32-character uuid.UsageAppbase.uuid()ReturnsString UUID</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#appbase-utility-servertime" class="ng-binding">serverTime()</a>
              <span class="hide ng-binding">serverTime()Obtain the current time in milliseconds since epoch.UsageAppbase.serverTime(onComplete)onComplete Function will be passed with two arguments.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference" class="ng-binding">NAMESPACE REFERENCE</a>
              <span class="hide ng-binding">Namespace ReferenceNamespace Reference Object or nsref has methods for creating vertices, searching vertices, and event listeners to the addition and removal of vertices.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-vertices" class="ng-binding">VERTICES</a>
              <span class="hide ng-binding">Vertices</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-vertices-v" class="ng-binding">v()</a>
              <span class="hide ng-binding">v()Creates a new vertex or obtains a reference to an existing vertex.Usagensref.v(path)Returnsvref Object Vertex ReferenceNote: Use a string identifier if you are creating a new vertex. A new vertex cannot be created recursively, avoid using non-existent paths.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-search" class="ng-binding">SEARCH</a>
              <span class="hide ng-binding">Search</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-search-search" class="ng-binding">search()</a>
              <span class="hide ng-binding">search()Powerful realtime search on vertices inside a namespace, with options to search using one or more data properties. It returns not just matched strings, but all the matching vertices.Note: Search has to be manually enabled on the namesapces using the Developer Dashboard.Usagensref.search(queryObj, onComplete)queryObj Object — A Javascript Object containing the following fields and valuesonComplete Function — will be passed two arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data" class="ng-binding">RETRIEVING DATA</a>
              <span class="hide ng-binding">Retrieving Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data-on" class="ng-binding">on()</a>
              <span class="hide ng-binding">on()Retrieve existing vertices, and listen to addition or removal of vertices.Usagensref.on(eventType , callback [, onComplete])callback Function (optional) — is called when with existing vertices, and when ever a new vertex is added. It will be passed two arguments:onComplete Function - Called when all the existing vertices have been retrieved. It will be called only once, with arguments:Note: vertex_added event listener returns the existing vertices in the namespace when listening for the first time.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data-off" class="ng-binding">off()</a>
              <span class="hide ng-binding">off()Turn off the listeners on a given namespace reference.nsref.off([eventType])</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-utility" class="ng-binding">UTILITY</a>
              <span class="hide ng-binding">Utility</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-utility-name" class="ng-binding">name()</a>
              <span class="hide ng-binding">name()Returns the name of the current reference.Usagensref.name()Returnsname String Name of the nsref.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-utility-path" class="ng-binding">path()</a>
              <span class="hide ng-binding">path()Returns the path of the current reference.Usagensref.path()The method accepts no arguments, and returns a path of the nsref resource. Since namespaces are top-level objects, the path for a namespace is just the namesapce identifier.Returnspath String Path of the nsref is usually the namespace identifier.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#namespace-reference-utility-url" class="ng-binding">URL()</a>
              <span class="hide ng-binding">URL()Appbase URL of the current reference.Usagensref.URL()The method accepts no arguments, and returns a URL of the nsref resource.Returnsurl String Data URL of the namespace reference. The format of the URL is api.appbase.io/:appname/:version/namespace.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference" class="ng-binding">VERTEX REFERENCE</a>
              <span class="hide ng-binding">Vertex ReferenceVertex Reference Object or vref has the methods for setting data, creating links to other vertices, and different listeners to notify about data changes, link changes, etc.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data" class="ng-binding">STORING DATA</a>
              <span class="hide ng-binding">Storing Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-setdata" class="ng-binding">setData()</a>
              <span class="hide ng-binding">setData()Set one or more data properties on this vertex reference.Usagevref.setData(dataObject [, onComplete])onComplete Function (optional) — will be passed two arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-commitdata" class="ng-binding">commitData()</a>
              <span class="hide ng-binding">commitData()Atomically modify properties of the vertex. Unlike setData(), which just overwrites the properties regardless of their previous values, commitData() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.Usagevref.commitData(applyFunction [, onComplete])onComplete Function (optional) — will be passed two arguments:applyFunction is called once and the new data is sent to the server for write. If another client writes to the vertex before your new value is successfully written, the applyFunction will be called again with the new current value, and the write will be retried.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-removedata" class="ng-binding">removeData()</a>
              <span class="hide ng-binding">removeData()Removes one or more data properties from this vertex reference.Usagevref.removeData(propertyName [, onComplete])onComplete Function (optional) — will be passed two arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-setedge" class="ng-binding">setEdge()</a>
              <span class="hide ng-binding">setEdge()Create a link to another vertex. You can optionally set priority to links.Usagevref.setEdge(edgeName [, outVertex, priority, onComplete])onComplete Function (optional) — will be passed three arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-removeedge" class="ng-binding">removeEdge()</a>
              <span class="hide ng-binding">removeEdge()Remove a link from the current vertex.Usagevref.removeEdge(edgeName [, onComplete])onComplete Function (optional) — will be passed two arguments:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-storing-data-destroy" class="ng-binding">destroy()</a>
              <span class="hide ng-binding">destroy()Destroys a vertex from Appbase. All edges pointing to this vertex are also removed. This causes vertex_removed to be fired on the namespace where this vertex belongs.Usagevref.destroy([, onComplete])onComplete Function (optional) — will be passed the argument:</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data" class="ng-binding">RETRIEVING DATA</a>
              <span class="hide ng-binding">Retrieving Data</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onproperties" class="ng-binding">on(‘properties’)</a>
              <span class="hide ng-binding">on(‘properties’)Fetch current properties, and listen to changes in the properties of a vertex.Usagevref.on('properties', callback)</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onceproperties" class="ng-binding">once(‘properties’)</a>
              <span class="hide ng-binding">once(‘properties’)As the name suggests, it works exactly like on("properties") except that it will be fired only once. When you want to fetch only the current properties and don’t want to listen to changes, you can use once().Usagevref.once('properties', callback)</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_added" class="ng-binding">on(‘edge_added’)</a>
              <span class="hide ng-binding">on(‘edge_added’)Get existing edges added at a location, and listen to new ones.Usagevref.on('edge_added' [, filters ],  callback [, onComplete])With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them.When more than one filter is provided, they work as logical AND and only the edges matchihg all filters will be fetched. This is what each filter means:Notice that:
 - Filters are a way to fetch existing edges, thus they work only with edge_added event
 - Edges are always returned ordered according to their priorities
 - When endAt &amp;lt; startAt, edges are returned in reverse order
 - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime
    - This means that the numeric filters can not be used with onlyNew set to be true
    - Newly created edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_removed" class="ng-binding">on(‘edge_removed’)</a>
              <span class="hide ng-binding">on(‘edge_removed’)Listen to removal of edges. Usagevref.on('edge_removed', callback)</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_changed" class="ng-binding">on(‘edge_changed’)</a>
              <span class="hide ng-binding">on(‘edge_changed’)When ever an edge is replaced, i.e. setEdge() is called with an existing edge name, this event is fired.Usagevref.on('edge_changed', callback)</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility" class="ng-binding">UTILITY</a>
              <span class="hide ng-binding">Utility</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility-outvertex" class="ng-binding">outVertex()</a>
              <span class="hide ng-binding">outVertex()Reference to the corresponding outVertex with the given name.Usagevref.outVertex(edgeName)Returns</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility-invertex" class="ng-binding">inVertex()</a>
              <span class="hide ng-binding">inVertex()Reference to the corresponding inVertex from the current vertex.Usagevref.inVertex()Note: Since vertices are accessed via a path, there is only one inVertex for each vertex. Calling this method on the root vertex such as ``Appbase.ns(“Domains”).v(“www.appbase.io”) will thrown an error.Returns</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility-path" class="ng-binding">path()</a>
              <span class="hide ng-binding">path()Returns the path of the current reference.Usagevref.path()The method accepts no arguments, and returns a path of the vref resource.Returnspath String Path of the vref is a UNIX style path of the format namespace/:vertex1/:vertex2/vref.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility-name" class="ng-binding">name()</a>
              <span class="hide ng-binding">name()Returns the name of the current reference.Usagevref.name()Returnsname String Name of the vref.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#vertex-reference-utility-url" class="ng-binding">URL()</a>
              <span class="hide ng-binding">URL()Appbase URL of the current reference.Usagevref.URL()The method accepts no arguments, and returns a URL of the vref resource.Returnsurl String Data URL of the namespace reference. The format of the URL is api.appbase.io/:appname/:version/ns/:vertex1/:vertex2.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#data-snapshots" class="ng-binding">DATA SNAPSHOTS</a>
              <span class="hide ng-binding">Data SnapshotsData snapshots are immutable copies of the data stored at Appbase References. There are two kinds of snapshots: Property Snapshot and Edge Snapshot_, fired when listening to on(‘properties’) or one of the edge listeners.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#data-snapshots-property-snapshot" class="ng-binding">Property Snapshot</a>
              <span class="hide ng-binding">Property SnapshotIt holds the property data of a vertex in Appbase. It has the following methods to obtain the changes in the Appbase Reference.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search --><li data-ng-repeat="doc in doc_content | filter:search" class="ng-scope">
              <a href="#/v2.0/javascript/api-reference/#data-snapshots-edge-snapshot" class="ng-binding">Edge Snapshot</a>
              <span class="hide ng-binding">Edge SnapshotIt holds the edge data. It has the following methods to obtain the edge related changes in the Appbase Reference.</span>
            </li><!-- end ngRepeat: doc in doc_content | filter:search -->
          </ul>
        </div>
      </li>
      <li class="dropdown">
        <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
           <span ng-bind="currentVersion" class="ng-binding">scalr</span> <span class="caret"></span>
        </a>
        <ul class="dropdown-menu version-switcher" role="menu">
          <!-- ngRepeat: version in versions --><li ng-repeat="version in versions" class="ng-scope">
            <a ng-href=../../scalr/concepts/intro.html ng-bind="version" class="ng-binding" href=../../scalr/concepts/intro.html>scalr</a>
          </li><!-- end ngRepeat: version in versions --><li ng-repeat="version in versions" class="ng-scope">
            <a ng-href=../../v2.0/concepts/datamodel.html ng-bind="version" class="ng-binding" href=../../v2.0/concepts/datamodel.html>v2.0</a>
          </li><!-- end ngRepeat: version in versions --><li ng-repeat="version in versions" class="ng-scope">
            <a ng-href=../../v3.0/changelog/changelog.html ng-bind="version" class="ng-binding" href=../../v3.0/changelog/changelog.html>v3.0</a>
          </li><!-- end ngRepeat: version in versions -->
        </ul>
      </li>
      <li class="github-star">
        <iframe src="https://ghbtns.com/github-btn.html?user=appbaseio&amp;repo=Docs&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
      </li>
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>
<div role="flatdoc" class="content-root ng-scope">
  <div class="menubar fixed">
    <div class="menu section" role="flatdoc-menu"><ul><li id="root-item" class="level-0"><ul class="level-1" id="root-list"><li id="appbase-data-model-item" class="level-1"><a id="appbase-data-model-link" href="../../scalr/concepts/datamodel.html#appbase-data-model" class="level-1" pref="#appbase-data-model">Appbase Data Model</a><ul class="level-2" id="appbase-data-model-list"><li id="appbase-data-model-what-is-appbaseio-item" class="level-2"><a id="appbase-data-model-what-is-appbaseio-link" href="../../scalr/concepts/datamodel.html#appbase-data-model-what-is-appbaseio" class="level-2" pref="#appbase-data-model-what-is-appbaseio">What is appbase.io</a></li></ul></li><li id="appbase-data-schema-item" class="level-1"><a id="appbase-data-schema-link" href="../../scalr/concepts/datamodel.html#appbase-data-schema" class="level-1" pref="#appbase-data-schema">Appbase Data Schema</a><ul class="level-2" id="appbase-data-schema-list"><li id="appbase-data-schema-app-aka-index-item" class="level-2"><a id="appbase-data-schema-app-aka-index-link" href="../../scalr/concepts/datamodel.html#appbase-data-schema-app-aka-index" class="level-2" pref="#appbase-data-schema-app-aka-index">App aka Index</a></li><li id="appbase-data-schema-type-item" class="level-2"><a id="appbase-data-schema-type-link" href="../../scalr/concepts/datamodel.html#appbase-data-schema-type" class="level-2" pref="#appbase-data-schema-type">Type</a></li><li id="appbase-data-schema-document-item" class="level-2"><a id="appbase-data-schema-document-link" href="../../scalr/concepts/datamodel.html#appbase-data-schema-document" class="level-2" pref="#appbase-data-schema-document">Document</a></li><li id="appbase-data-schema-visualizing-the-data-model-item" class="level-2"><a id="appbase-data-schema-visualizing-the-data-model-link" href="../../scalr/concepts/datamodel.html#appbase-data-schema-visualizing-the-data-model" class="level-2" pref="#appbase-data-schema-visualizing-the-data-model">Visualizing the Data Model</a></li></ul></li></ul></li></ul></div>
  </div>
  <div role="flatdoc-content" class="content"><div class="extra_container"><div class="contributors_header"><strong>Contributors<strong></strong></strong><span class="pull-right modified-date">Last Modified On : <a href="https://github.com/appbaseio/Docs/commit/9683e5f074953e97618dcc5acc576b785d93a286">Sep 18, 2015</a></span></div><div class="contributor-container"><a class="contributor" href="https://github.com/siddharthlatest" title="siddharthlatest" target="_blank"><img class="contributor_img img-rounded" src="https://avatars.githubusercontent.com/u/630042?v=3" alt="siddharthlatest"></a></div></div><div class="clearFix"></div><h1 id="appbase-data-model">Appbase Data Model</h1><h2 id="appbase-data-model-what-is-appbaseio">What is appbase.io</h2><p><a href="https://appbase.io">Appbase.io</a> is a data streams API service for continuous search and aggregation queries. You can build reactive apps with Appbase.io, where views update in conjunction with the data changes.</p><p>It enables you to:  </p><ul>
<li>Build a blazing fast text search, messaging systems, or implement a mix of esoteric filters (fuzzy, geo, terms, range, multiple items),</li>
<li>Stream JSON results directly as new data is added or the original data is updated,  </li>
<li>Scale seamlessly upto 10,000 updates per second and store at terbyte scale.</li>
</ul><p><img src="http://i.imgur.com/iJpqtks.png?1" alt="Appbase Architecture"><br><strong>Image 1:</strong> It provides a reliable data streams API as a service, while leveraging ElasticSearch (and Lucene) for storage and search.</p><p>While not primarily intended, Appbase.io can also be used as a hosted ElasticSearch API or as a message queue with a publish / subscribe model.</p><p>There are some catches if you intend to:  </p><ul>
<li>Use it as a primary data store - ElasticSearch is <a href="https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html#_loss_of_documents_during_network_partition_status_ongoing">known to lose data</a> for some time on network partitions.<br><code>Status:</code> We are working towards adding support for durability by using Apache Kafka as a frontend (things you can do in SaaS!).</li>
<li>Model financial or sensitive data - Appbase.io is not ACIDic and we don’t intend to be. A good design choice in this situation would be to use something that supports ACID transactions for storing sensitive data, and use Appbase.io for the data that needs to be searchable or accessed in realtime.</li>
<li>Use it for OLAP use-cases - Appbase.io is designed as an OLTP system although it supports aggregations and queries on data sets of the size of terabytes. There are plenty of ideal tools for OLAP use-cases - Amazon Redshift, Google Big Query, Apache Hadoop and Appbase.io can be used with any of them (via REST API).</li>
</ul><h1 id="appbase-data-schema">Appbase Data Schema</h1><p>Appbase uses the same data schema as ElasticSearch.</p><h2 id="appbase-data-schema-app-aka-index">App <span style="font-weight: 200;">aka Index</span></h2><p>An app in <a href="https://appbase.io">appbase.io</a> is stored as an index in ElasticSearch. App is the highest level of construct supported by appbase and is equivalent to a <strong>database</strong> in SQL.</p><h2 id="appbase-data-schema-type">Type</h2><p>Types are equivalent to <strong>tables</strong> in SQL. Data in an app is always stored within it’s types. A good way to think of them is as collections of different kinds of data.</p><h2 id="appbase-data-schema-document">Document</h2><p>A <strong>document</strong> is the actual data stored in Appbase. Documents are <code>JSON</code> objects, equivalent to <strong>records</strong> or <strong>rows</strong> in SQL.</p><pre><code class="lang-js prettyprint prettyprinted" style=""><span class="pun">{</span><span class="pln">
   </span><span class="string"><span class="str">"user"</span></span><span class="pun">:</span><span class="pln"> </span><span class="string"><span class="str">"data"</span></span><span class="pun">,</span><span class="pln">
   </span><span class="string"><span class="str">"remember"</span></span><span class="pun">:</span><span class="pln"> </span><span class="string"><span class="str">"something"</span></span><span class="pun">,</span><span class="pln">
   </span><span class="string"><span class="str">"molala"</span></span><span class="pun">:</span><span class="pln"> </span><span class="string"><span class="str">"yaya"</span></span><span class="pun">,</span><span class="pln">
   </span><span class="string"><span class="str">"lifeis"</span></span><span class="pun">:</span><span class="pln"> </span><span class="number"><span class="lit">42</span></span><span class="pun">,</span><span class="pln">
   </span><span class="string"><span class="str">"recursive"</span></span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
           </span><span class="string"><span class="str">"how's this"</span></span><span class="pun">:</span><span class="pln"> </span><span class="string"><span class="str">"one nested value"</span></span><span class="pln">
   </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre><p><br></p><h2 id="appbase-data-schema-visualizing-the-data-model">Visualizing the Data Model</h2><p>An app can have one or more types and each type is a container for JSON documents. Visually, the arrangement looks like below:</p><p><img src="https://farm1.staticflickr.com/616/21319701888_dbe75d9f6f_c.jpg" alt="img"></p></div>
  <a class="edit" ng-href="https://github.com/appbaseio/Docs/tree/master/src/scalr/concepts/datamodel.md" target="_blank" href="https://github.com/appbaseio/Docs/tree/master/src/scalr/concepts/datamodel.md">
    <span class="fa fa-pencil"> Edit</span>
  </a>
</div></div>
  <script type="text/javascript" src="../../scripts/analytics.js"></script>
  <script type="text/javascript" src="../../scripts/main.js"></script>
  <script type="text/javascript" src="../../bower_components/bootstrap/dist/js/bootstrap.min.js"></script>

</body></html>