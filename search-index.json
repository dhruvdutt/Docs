[{"content":"<h1>Appbase <b>Documentation</b></h1>","link":"/","title":"Appbase Documentation"},{"content":"<h1 id=\"api-prime-objective-scale\"><img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"SCALR\"> API Prime Objective: Scale</h1><p>As the name suggests, our prime focus with this iteration of the API has been achieving a massive scale of API operations, to the tune of <a href=\"http://news.appbase.io/scaling-elasticsearch-writes/\">100,000 writes</a> and reads (yet to corroborate) per second. </p><p>You might wonder - why is addressing scale so important? A typical successful application would never exceed a throughput of a  few hundred requests per second and generally be okay with serving responses in time.</p><p>So much complexity in software comes from trying to make one thing do two things.<br>-Ryan Singer</p><p>This quote from Ryan Singer especially sings true when one thinks of scaling database operations. So much of the software service complexities stem from keeping up with the infrastructure needs, that those end up turning into burning pain points. It should come as no surprise that most mainstream distributed systems were born out of the scaling pain points faced by the 0.01% of the applications.</p><p>Not only does addressing scale solve the burning pain points faced by the 0.01%, it provides confidence around the edge-cases and leads to faster adoption in production environments and success stories. We hope all of these come true for SCALR. In building SCALR, focusing on scale has lead us to a better foundational design, a more rigorously tested codebase, and a fine-grained monitoring of our deployment infrastructure. We’ll go more in depth about these learnings over the next few months, but most importantly - for the 99.9% folks reading this, <code>SCALR</code> has tons of improvements and features over <code>v2</code>.</p>","link":"#/scalr/#api-prime-objective-scale","title":" API PRIME OBJECTIVE: SCALE"},{"content":"<h1 id=\"git-diff-changes-human\">git diff changes —human</h1><p>Welcome to the land of SCALR, where everyone smiles and the sun shines bright. </p><p><img src=\"http://i.imgur.com/3nYaIQM.png?1\" alt=\"SCALR banner image\"></p><p>And our beloved Hobo Lobo is typing out a 101 of ‘SCALR’. </p><p>“What changes?”, asks someone.<br>“Everything”, comes the curt reply from Hobo Lobo.</p>","link":"#/scalr/#git-diff-changes-human","title":"GIT DIFF CHANGES —HUMAN"},{"content":"<h2 id=\"git-diff-changes-human-scalr-whats-in-a-name\"><code>SCALR</code> - What’s in a name</h2><p>The most tangible change is in the codename - <code>scalr</code>. Breaking the convention of keeping a dull version name like <code>v2.0</code>, we will go with the version <code>scalr</code>. Docs for scalr are available at <a href=\"\"></a><a href=\"http://docs.appbase.io/#/scalr/\">http://docs.appbase.io/#/scalr/</a> and the API base URL would be <code>https://scalr.api.appbase.io</code>.</p>","link":"#/scalr/#git-diff-changes-human-scalr-whats-in-a-name","title":"SCALR - WHAT’S IN A NAME"},{"content":"<h2 id=\"git-diff-changes-human-compatibility-with-elasticsearch\">Compatibility with ElasticSearch</h2><p><code>scalr</code> is compatible out of the box with the ElasticSearch APIs. This means our users can take advantage of the vast plethora of client libraries made available by the folks at Elastic, have access to a vibrant open-source community and have the freedom to import / export data from <a href=\"\">Appbase.io</a> conveniently. </p>","link":"#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch","title":"COMPATIBILITY WITH ELASTICSEARCH"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication\">HTTP Basic Authentication</h3><p><code>scalr</code> uses HTTP Basic Authentication for securing app access (similar to Github and Wordpress’s authentication mechanisms). Every Appbase app can have one or more access tokens (username, password) with granular read and write permissions to allow fine-grained access. ElasticSearch’s access tokens work in the same way, a major compatibility win.</p><p>Note: This is a change from the earlie  r use of an authentication header <code>Appbase-Secret</code>.</p>","link":"#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication","title":"HTTP Basic Authentication"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible\">What’s not compatible?</h3><p>The APIs related to devops, like clusters, multi-index operations, index creation are not a part of Appbase.io.</p>","link":"#/scalr/#git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible","title":"What’s not compatible?"},{"content":"<h2 id=\"git-diff-changes-human-data-streams-20\">Data Streams 2.0</h2><p>Data Streams aka realtime events are rethought in <code>SCALR</code>. Instead of being a websockets based extension of the API to track just the document and reference changes, data streams are deeply baked into the <code>SCALR</code> API. Data Streams are implemented over <strong>http-streaming</strong> and are pervasive over web, mobile and language native libraries. Data Streams can stream results of queries and filters as new data comes into the system.</p>","link":"#/scalr/#git-diff-changes-human-data-streams-20","title":"DATA STREAMS 2.0"},{"content":"<h2 id=\"git-diff-changes-human-adieu-to-graph-datamodel\">Adieu to Graph datamodel</h2><p><code>SCALR</code> the JSON based schema-free datamodel of ElasticSearch. This is a major change over the graph datamodel extensively used by the <code>v2</code> API. The move is aimed at simplicity and to provide a less opinionated data model. True graph relationships can still be modeled in <code>SCALR</code>.</p>","link":"#/scalr/#git-diff-changes-human-adieu-to-graph-datamodel","title":"ADIEU TO GRAPH DATAMODEL"},{"content":"<h1 id=\"api-prime-objective-scale\"><img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"SCALR\"> API Prime Objective: Scale</h1><p>As the name suggests, our prime focus with this iteration of the API has been achieving a massive scale of API operations, to the tune of <a href=\"http://news.appbase.io/scaling-elasticsearch-writes/\">100,000 writes</a> and reads (yet to corroborate) per second. </p><p>You might wonder - why is addressing scale so important? A typical successful application would never exceed a throughput of a  few hundred requests per second and generally be okay with serving responses in time.</p><p>So much complexity in software comes from trying to make one thing do two things.<br>-Ryan Singer</p><p>This quote from Ryan Singer especially sings true when one thinks of scaling database operations. So much of the software service complexities stem from keeping up with the infrastructure needs, that those end up turning into burning pain points. It should come as no surprise that most mainstream distributed systems were born out of the scaling pain points faced by the 0.01% of the applications.</p><p>Not only does addressing scale solve the burning pain points faced by the 0.01%, it provides confidence around the edge-cases and leads to faster adoption in production environments and success stories. We hope all of these come true for SCALR. In building SCALR, focusing on scale has lead us to a better foundational design, a more rigorously tested codebase, and a fine-grained monitoring of our deployment infrastructure. We’ll go more in depth about these learnings over the next few months, but most importantly - for the 99.9% folks reading this, <code>SCALR</code> has tons of improvements and features over <code>v2</code>.</p>","link":"#/scalr/concepts/intro/#api-prime-objective-scale","title":" API PRIME OBJECTIVE: SCALE"},{"content":"<h1 id=\"git-diff-changes-human\">git diff changes —human</h1><p>Welcome to the land of SCALR, where everyone smiles and the sun shines bright. </p><p><img src=\"http://i.imgur.com/3nYaIQM.png?1\" alt=\"SCALR banner image\"></p><p>And our beloved Hobo Lobo is typing out a 101 of ‘SCALR’. </p><p>“What changes?”, asks someone.<br>“Everything”, comes the curt reply from Hobo Lobo.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human","title":"GIT DIFF CHANGES —HUMAN"},{"content":"<h2 id=\"git-diff-changes-human-scalr-whats-in-a-name\"><code>SCALR</code> - What’s in a name</h2><p>The most tangible change is in the codename - <code>scalr</code>. Breaking the convention of keeping a dull version name like <code>v2.0</code>, we will go with the version <code>scalr</code>. Docs for scalr are available at <a href=\"\"></a><a href=\"http://docs.appbase.io/#/scalr/\">http://docs.appbase.io/#/scalr/</a> and the API base URL would be <code>https://scalr.api.appbase.io</code>.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-scalr-whats-in-a-name","title":"SCALR - WHAT’S IN A NAME"},{"content":"<h2 id=\"git-diff-changes-human-compatibility-with-elasticsearch\">Compatibility with ElasticSearch</h2><p><code>scalr</code> is compatible out of the box with the ElasticSearch APIs. This means our users can take advantage of the vast plethora of client libraries made available by the folks at Elastic, have access to a vibrant open-source community and have the freedom to import / export data from <a href=\"\">Appbase.io</a> conveniently. </p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch","title":"COMPATIBILITY WITH ELASTICSEARCH"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication\">HTTP Basic Authentication</h3><p><code>scalr</code> uses HTTP Basic Authentication for securing app access (similar to Github and Wordpress’s authentication mechanisms). Every Appbase app can have one or more access tokens (username, password) with granular read and write permissions to allow fine-grained access. ElasticSearch’s access tokens work in the same way, a major compatibility win.</p><p>Note: This is a change from the earlie  r use of an authentication header <code>Appbase-Secret</code>.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication","title":"HTTP Basic Authentication"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible\">What’s not compatible?</h3><p>The APIs related to devops, like clusters, multi-index operations, index creation are not a part of Appbase.io.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible","title":"What’s not compatible?"},{"content":"<h2 id=\"git-diff-changes-human-data-streams-20\">Data Streams 2.0</h2><p>Data Streams aka realtime events are rethought in <code>SCALR</code>. Instead of being a websockets based extension of the API to track just the document and reference changes, data streams are deeply baked into the <code>SCALR</code> API. Data Streams are implemented over <strong>http-streaming</strong> and are pervasive over web, mobile and language native libraries. Data Streams can stream results of queries and filters as new data comes into the system.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-data-streams-20","title":"DATA STREAMS 2.0"},{"content":"<h2 id=\"git-diff-changes-human-adieu-to-graph-datamodel\">Adieu to Graph datamodel</h2><p><code>SCALR</code> the JSON based schema-free datamodel of ElasticSearch. This is a major change over the graph datamodel extensively used by the <code>v2</code> API. The move is aimed at simplicity and to provide a less opinionated data model. True graph relationships can still be modeled in <code>SCALR</code>.</p>","link":"#/scalr/concepts/intro/#git-diff-changes-human-adieu-to-graph-datamodel","title":"ADIEU TO GRAPH DATAMODEL"},{"content":"<h1 id=\"appbase-data-model\">Appbase Data Model</h1>","link":"#/scalr/concepts/datamodel/#appbase-data-model","title":"APPBASE DATA MODEL"},{"content":"<h2 id=\"appbase-data-model-what-is-appbaseio\">What is appbase.io</h2><p><a href=\"https://appbase.io\">Appbase.io</a> is a data streams API service for continuous search and aggregation queries. You can build reactive apps with Appbase.io, where views update in conjunction with the data changes.</p><p>It enables you to:  </p><p><img src=\"http://i.imgur.com/iJpqtks.png?1\" alt=\"Appbase Architecture\"><br><strong>Image 1:</strong> It provides a reliable data streams API as a service, while leveraging ElasticSearch (and Lucene) for storage and search.</p><p>While not primarily intended, Appbase.io can also be used as a hosted ElasticSearch API or as a message queue with a publish / subscribe model.</p><p>There are some catches if you intend to:  </p>","link":"#/scalr/concepts/datamodel/#appbase-data-model-what-is-appbaseio","title":"WHAT IS APPBASE.IO"},{"content":"<h1 id=\"appbase-data-schema\">Appbase Data Schema</h1><p>Appbase uses the same data schema as ElasticSearch.</p>","link":"#/scalr/concepts/datamodel/#appbase-data-schema","title":"APPBASE DATA SCHEMA"},{"content":"<h2 id=\"appbase-data-schema-app-aka-index\">App <span style=\"font-weight: 200;\">aka Index</span></h2><p>An app in <a href=\"https://appbase.io\">appbase.io</a> is stored as an index in ElasticSearch. App is the highest level of construct supported by appbase and is equivalent to a <strong>database</strong> in SQL.</p>","link":"#/scalr/concepts/datamodel/#appbase-data-schema-app-aka-index","title":"APP AKA INDEX"},{"content":"<h2 id=\"appbase-data-schema-type\">Type</h2><p>Types are equivalent to <strong>tables</strong> in SQL. Data in an app is always stored within it’s types. A good way to think of them is as collections of different kinds of data.</p>","link":"#/scalr/concepts/datamodel/#appbase-data-schema-type","title":"TYPE"},{"content":"<h2 id=\"appbase-data-schema-document\">Document</h2><p>A <strong>document</strong> is the actual data stored in Appbase. Documents are <code>JSON</code> objects, equivalent to <strong>records</strong> or <strong>rows</strong> in SQL.</p><p><br></p>","link":"#/scalr/concepts/datamodel/#appbase-data-schema-document","title":"DOCUMENT"},{"content":"<h2 id=\"appbase-data-schema-visualizing-the-data-model\">Visualizing the Data Model</h2><p>An app can have one or more types and each type is a container for JSON documents. Visually, the arrangement looks like below:</p><p><img src=\"https://farm1.staticflickr.com/616/21319701888_dbe75d9f6f_c.jpg\" alt=\"img\"></p>","link":"#/scalr/concepts/datamodel/#appbase-data-schema-visualizing-the-data-model","title":"VISUALIZING THE DATA MODEL"},{"content":"<h1 id=\"quick-start-to-the-js-api\">Quick Start to the <img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"Scalr\"> JS API</h1><p><a href=\"https://github.com/appbaseio/appbase-js\">Appbase.JS</a> is a minimalistic library for data streams.  </p><p>It can:</p><p>It can’t:  </p><p><a href=\"https://appbase.io\">Appbase</a> is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.</p><p>This is a quick start guide to whet the appetite with the possibilities of data streams.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api","title":"QUICK START TO THE  JS API"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for a simple username/password authentication.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-0-creating-an-app","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-1-lib-setup\">Step 1: Lib Setup</h2><p>We will fetch and install the <strong>appbase-js</strong> lib using <a href=\"http://bower.io\">bower</a>. We will use <code>v0.8.0</code> for specificity. </p><p>Requiring the lib takes just one line of html script injection:</p><p>To write data or stream updates from <a href=\"https://appbase.io\">appbase.io</a>, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the <code>Appbase</code> constructor:</p><p><strong>OR</strong></p><p>Alternatively, username:password can be passed as a part of the API URL in the constructor.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-1-lib-setup","title":"STEP 1: LIB SETUP"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-2-storing-data\">Step 2: Storing Data</h2><p>Once we have the reference object (called <code>appbase</code> in this tutorial), we can insert any JSON object into it with the <code>index()</code> method.</p><p>where <code>type: 'books'</code> indicate the collection (or table) inside which the data will be stored and the<code>id: '1'</code> is an optional unique identifier.</p><p>The <code>index()</code> method (and all the other <code>appbase</code> methods) return a <a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream</a> object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes.</p><p><span class=\"fa fa-info-circle\"></span> If you have noticed, SCALR uses the same APIs and data modeling conventions as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-2-storing-data","title":"STEP 2: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-3-geting-err-streaming-data\">Step 3: <s>GETing</s> err, Streaming Data</h2><p>Now that we are able to store data, let’s try to get the data back from <a href=\"https://appbase.io\">appbase.io</a> with the <code>readStream()</code> method.</p><p>Now everytime there is a document update, our ‘data’ event handler will emit the document with the final value.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-err-streaming-data","title":"STEP 3: GETING ERR, STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-js-api-step-3-geting-err-streaming-data-3a-modify-the-document\">3.a: Modify the Document</h3><p>Let’s see this in action. We will modify the book price in our original <code>jsonObject</code> variable from 5595 to 6034.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-err-streaming-data-3a-modify-the-document","title":"3.a: Modify the Document"},{"content":"<h3 id=\"quick-start-to-the-js-api-step-3-geting-err-streaming-data-3b-observe-the-streams\">3.b: Observe the Streams</h3><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.</p><p><code>Note:</code> Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by keeping the state using the composition of (_type, _id) fields.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-3-geting-err-streaming-data-3b-observe-the-streams","title":"3.b: Observe the Streams"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-4-streaming-rich-queries\">Step 4: Streaming Rich Queries</h2><p>Streaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data? The <code>searchStream()</code> method scratches this itch perfectly. </p><p>In the example below, we will see it in action with a <code>match_all</code> query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.</p><p>In this tutorial, we have learnt how to index new data and stream both individual data and results of an expressive query. <a href=\"https://appbase.io\">Appbase.io</a> supports a wide range of queries.</p><p>For next steps, check out our <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">Javascript API reference</a> or take a look at the <span class=\"fa fa-external-link-square\"></span><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html\">ElasticSearch JS reference</a> for a deeper dive.</p>","link":"#/scalr/javascript/javascript-intro/#quick-start-to-the-js-api-step-4-streaming-rich-queries","title":"STEP 4: STREAMING RICH QUERIES"},{"content":"<h1 id=\"quick-start-to-the-nodejs-api\">Quick Start to the <img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"Scalr\"> Node.JS API</h1><p><a href=\"https://github.com/appbaseio/appbase-js\">Appbase.JS</a> is a minimalistic library for data streams.  </p><p>It can:</p><p>It can’t:  </p><p>Also, <a href=\"https://appbase.io\">Appbase</a> is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.</p><p>This is a quick start guide to whet the appetite with the possibilities of data streams.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api","title":"QUICK START TO THE  NODE.JS API"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for a simple username/password authentication.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-0-creating-an-app","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-1-lib-setup\">Step 1: Lib Setup</h2><p>We will fetch and install the <strong>appbase-js</strong> lib via <a href=\"https://www.npmjs.com/package/appbase-js\">npm</a>, current version should be v0.8.0.</p><p>Requiring the lib takes one line:</p><p>To write data or stream updates from <a href=\"https://appbase.io\">appbase.io</a>, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the <code>Appbase</code> constructor:</p><p><strong>OR</strong></p><p>Alternatively, username:password can be passed as a part of the API URL in the constructor.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-1-lib-setup","title":"STEP 1: LIB SETUP"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-2-storing-data\">Step 2: Storing Data</h2><p>Once we have the reference object (called <code>appbase</code> in this tutorial), we can insert any JSON object into it with the <code>index()</code> method.</p><p>where <code>type: 'books'</code> indicates the collection (or table) inside which the data will be stored and the<code>id: '1'</code> is an optional unique identifier.</p><p>The <code>index()</code> method (and all the other <code>appbase</code> methods) return a <a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream</a> object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes.</p><p><span class=\"fa fa-info-circle\"></span> If you have noticed, SCALR uses the same APIs and data modeling conventions as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-2-storing-data","title":"STEP 2: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data\">Step 3: <s>GETing</s> err, Streaming Data</h2><p>Now that we are able to store data, let’s try to get the data back from <a href=\"https://appbase.io\">appbase.io</a> with the <code>readStream()</code> method.</p><p>Everytime there is a document update, our ‘data’ event handler will emit the document with the final value.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data","title":"STEP 3: GETING ERR, STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data-3a-modify-the-document\">3.a: Modify the Document</h3><p>Let’s see this in action. We will modify the book price in our original <code>jsonObject</code> variable from 5595 to 6034.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data-3a-modify-the-document","title":"3.a: Modify the Document"},{"content":"<h3 id=\"quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data-3b-observe-the-streams\">3.b: Observe the Streams</h3><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.</p><p><code>Note:</code> Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by keeping the state using the composition of (_type, _id) fields.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-3-geting-err-streaming-data-3b-observe-the-streams","title":"3.b: Observe the Streams"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-4-streaming-rich-queries\">Step 4: Streaming Rich Queries</h2><p>Streaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data? The <code>searchStream()</code> method scratches this itch perfectly. </p><p>In the example below, we will see it in action with a <code>match_all</code> query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.</p><p>In this tutorial, we learned how to index new data and stream 1.) individual data document and 2.) results of a data query. <a href=\"https://appbase.io\">Appbase.io</a> supports a wide range of queries.</p><p>For next steps, check out our <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">Javascript API reference</a> or take a look at the <span class=\"fa fa-external-link-square\"></span><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html\">ElasticSearch JS reference</a> for a deeper dive.</p>","link":"#/scalr/javascript/nodejs-intro/#quick-start-to-the-nodejs-api-step-4-streaming-rich-queries","title":"STEP 4: STREAMING RICH QUERIES"},{"content":"<h1 id=\"how-to\">How to</h1>","link":"#/scalr/FAQs/rest/#how-to","title":"HOW TO"},{"content":"<h2 id=\"how-to-update-mapping-without-losing-data\">Update mapping without losing data</h2><p>Although you can add new types to an index, or add new fields to a type, you can’t add new analyzers or make changes to existing fields. If you were to do so, the data that had already been indexed would be incorrect and your searches would no longer work as expected. Here’s a short gist on how mappings work:</p><p>In order to make your data searchable, your database needs to know what type of data each field contains and how it should be indexed. If you switch a field type from e.g. a string to a date, all of the data for that field that you already have indexed cannot be used because of the datatype mismatch. In such situations, you need to reindex that field.</p><p>This applies not just to Appbase (or Elasticsearch / Lucene - the datastore used by Appbase), but to any database that uses indices for searching. And if it isn’t using indices then it is sacrificing speed for flexibility.</p><p>There is one situation where re-indexing is not required: when adding a field, as a previous mapping for the field didn’t exist and Appbase can infer the field datatype when it’s indexed for the first time.</p><p>Since updating mapping =&gt; reindexing data, let’s take a look at that.</p>","link":"#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data","title":"UPDATE MAPPING WITHOUT LOSING DATA"},{"content":"<h3 id=\"how-to-update-mapping-without-losing-data-reindexing-your-data\">Reindexing your data</h3><p>The process for reindexing your data is quite simple. First, create a new app in appbase and update the new mapping and settings:  </p><p>One of the advantages of the _source field is that you already have the whole document available to you in Elasticsearch itself. You don’t have to rebuild your index from the database, which is usually much slower.</p><p>To reindex all of the documents from the old index efficiently, use <a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/scan-scroll.html\">scan-and-scroll</a> to retrieve batches of documents from the old index, and the <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-writing-data-bulk\">bulk API</a> to push them into the new index.</p>","link":"#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data-reindexing-your-data","title":"Reindexing your data"},{"content":"<h3 id=\"how-to-update-mapping-without-losing-data-reindexing-in-batches\">Reindexing in Batches</h3><p>You can run multiple reindexing jobs at the same time, but you obviously don’t want their results to overlap. Instead, break a big reindex down into smaller jobs by filtering on a date or timestamp field:  </p><p>If you continue making changes to the old app, you will want to make sure that you include the newly added documents in your new app as well. This can be done by rerunning the reindex process, but again filtering on a date field to match only documents that have been added since the last reindex process started.</p><p>Reference: <a href=\"https://www.elastic.co/blog/changing-mapping-with-zero-downtime\">Elastic Search blog</a></p>","link":"#/scalr/FAQs/rest/#how-to-update-mapping-without-losing-data-reindexing-in-batches","title":"Reindexing in Batches"},{"content":"<h1 id=\"how-to\">How to</h1>","link":"#/scalr/FAQs/jsapi/#how-to","title":"HOW TO"},{"content":"<h2 id=\"how-to-unsubscribe-from-a-streaming-query\">Unsubscribe from a streaming query</h2><p>The JS API methods for the <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-setup-new-appbase\"><code>appbaseRef</code></a> object implement a <strong>streams</strong> interface. Let’s see an example:</p><p>Unsubscribing from the <code>responseStream</code> is simple: using <code>stop()</code> method.</p><p><span class=\"fa fa-info-circle\"></span> The same is true for all other methods (like <code>index()</code>, <code>readStream()</code>) as well, data is returned asynchronously via the ‘data’ event handler.</p>","link":"#/scalr/FAQs/jsapi/#how-to-unsubscribe-from-a-streaming-query","title":"UNSUBSCRIBE FROM A STREAMING QUERY"},{"content":"<h2 id=\"how-to-pause-a-streaming-query\">Pause a streaming query</h2><p><a href=\"https://nodejs.org/api/stream.html#stream_readable_pause\">Pausing a response stream object</a> prevents new data responses from emitting. The stream can be resumed again via conveniently named <code>responseStream.resume()</code>.</p><p><span class=\"fa fa-info-circle\"></span> <strong>pause()</strong> vs <strong>stop()</strong> - pause() merely prevents emitting new ‘data’ event handlers, the response stream object still continues to capture the new events emitted by the searchStream() method. In contrast, stop() unsubscribes from the query and kills the response stream object.</p><p><span class=\"fa fa-star\"></span> Check out more things you can do with streams here -  <a href=\"http://www.sitepoint.com/basics-node-js-streams/\">http://www.sitepoint.com/basics-node-js-streams/</a>.</p>","link":"#/scalr/FAQs/jsapi/#how-to-pause-a-streaming-query","title":"PAUSE A STREAMING QUERY"},{"content":"<h2 id=\"how-to-stream-results-of-a-range-query\">Stream results of a range query</h2><p>Appbase.io implements a streaming interface for the entire <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl.html\">Query DSL</a> supported by ElasticSearch. So if we can compose a range query, making it return continuous results is easy.</p><p>Let’s say we have a <strong>type</strong> called <em>items</em> which contains items with their corresponding value. An example document inside the <em>items</em> type looks like:</p><p>Composing the query:</p><p>The default state of <code>responseStream</code> object is paused. As soon as attach a data handler to it, it will start streaming the responses.</p>","link":"#/scalr/FAQs/jsapi/#how-to-stream-results-of-a-range-query","title":"STREAM RESULTS OF A RANGE QUERY"},{"content":"<h2 id=\"how-to-change-the-default-results-in-a-search-query\">Change the default results in a search query</h2><p>Appbase returns 10 objects in the initial response to <code>searchStream()</code> method. Sometimes, we need to return more objects. We can do this by specifying the <code>size</code> attribute inside our query like this:</p><p>The <code>responseStream</code> object will now return max(total_objects_matching_our_query, 100) objects on the <code>'data'</code> event handler.</p><p><span class=\"fa fa-star\"></span> The <code>size</code> attribute can specify a maximum of 1000 objects to return in one response.</p><p><span class=\"fa fa-info-circle\"></span> <code>size</code> attribute can be applied on both <code>searchStream()</code> and <code>search()</code> methods.</p>","link":"#/scalr/FAQs/jsapi/#how-to-change-the-default-results-in-a-search-query","title":"CHANGE THE DEFAULT RESULTS IN A SEARCH QUERY"},{"content":"<h1 id=\"major-changes\">Major changes</h1>","link":"#/v3.0/#major-changes","title":"MAJOR CHANGES"},{"content":"<h3 id=\"major-changes-1-json-document-based-model\">1. JSON Document based Model</h3><p>With v3.0, Appbase adopts the JSON based document schema model (similar to MongoDB and ElasticSearch). We are bringing the simplicity of JSON based data models to Appbase with this major revision while still maintaining index-free adjency references for each document.</p><p>Here’s how the mapping works if you are familiar with the v2.0 API:</p>","link":"#/v3.0/#major-changes-1-json-document-based-model","title":"1. JSON Document based Model"},{"content":"<h3 id=\"major-changes-2-rest-api-format\">2. REST API Format</h3><p>The overall API format has been made more expressive.</p>","link":"#/v3.0/#major-changes-2-rest-api-format","title":"2. REST API Format"},{"content":"<h1 id=\"javascript-api-reference\">Javascript API Reference</h1><p>Appbase.JS is a minimalistic library for data streams.</p><p>It can:</p><p>You can read the <a href=\"http://docs.appbase.io/scalr/javascript/javascript-intro.html\">Javascript</a> or <a href=\"http://docs.appbase.io/scalr/javascript/nodejs-intro.html\">Node.JS</a> quick-start guides for installation and basic usage.</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference","title":"JAVASCRIPT API REFERENCE"},{"content":"<h2 id=\"javascript-api-reference-setup\">SETUP</h2>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-setup","title":"SETUP"},{"content":"<h3 id=\"javascript-api-reference-setup-new-appbase\">new Appbase()</h3><p>Returns a new Appbase object (refered to as <code>appbaseRef</code> in all the following examples) using the <code>url</code>, <code>appname</code> and <code>username</code>:<code>password</code> credentials.</p><p><strong>Usage</strong></p><p><code>new Appbase(appData)</code></p><p><strong>appData</strong> <code>Object</code> - A Javascript object containing the following fields and values</p><p><strong>Returns</strong></p><p><code>Object</code> <strong>appbaseRef</strong> <em>Appbase reference object</em> - has <code>index()</code>, <code>delete()</code>, <code>bulk()</code>, <code>search()</code>, <code>get()</code>, <code>getTypes()</code>, <code>getStream()</code> and <code>searchStream()</code> methods.</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-setup-new-appbase","title":"new Appbase()"},{"content":"<h2 id=\"javascript-api-reference-writing-data\">WRITING DATA</h2>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-writing-data","title":"WRITING DATA"},{"content":"<h3 id=\"javascript-api-reference-writing-data-index\">index()</h3><p>Writes a JSON data object at a given <code>type</code> and <code>id</code> location, or updates if an object already exists.</p><p><strong>Usage</strong></p><p><code>appbaseRef.index(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the type, id and the JSON data to be indexed</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-index","title":"index()"},{"content":"<h3 id=\"javascript-api-reference-writing-data-delete\">delete()</h3><p>Delete a JSON data object by <code>id</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.delete(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the JSON object to be deleted</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-delete","title":"delete()"},{"content":"<h3 id=\"javascript-api-reference-writing-data-bulk\">bulk()</h3><p>Apply many index / delete operations together, useful when importing data for the first time.</p><p><strong>Usage</strong></p><p><code>appbaseRef.bulk(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>body</code> and optionally a default <code>type</code> to be used for actions</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-writing-data-bulk","title":"bulk()"},{"content":"<h2 id=\"javascript-api-reference-getting-data\">GETTING DATA</h2>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-getting-data","title":"GETTING DATA"},{"content":"<h3 id=\"javascript-api-reference-getting-data-get\">get()</h3><p>Get the JSON document from a particular <code>type</code> and <code>id</code>. For subscribing to realtime updates on a document, check out <code>getStream()</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.get(params)</code></p><p>Returns the document at the given <code>type</code> and <code>id</code>.</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-get","title":"get()"},{"content":"<h3 id=\"javascript-api-reference-getting-data-gettypes\">getTypes()</h3><p>Get all the <code>types</code> of an appname.</p><p><strong>Usage</strong></p><p><code>appbaseRef.getTypes()</code></p><p>Returns all the <code>types</code> as an array.</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-gettypes","title":"getTypes()"},{"content":"<h3 id=\"javascript-api-reference-getting-data-search\">search()</h3><p>Search for matching documents in a type. It’s a convenience method for ElasticSearch’s <code>/_search</code> endpoint.  For subscribing to realtime updates on the search query, check out <code>searchStream()</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.search(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code>.</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-getting-data-search","title":"search()"},{"content":"<h2 id=\"javascript-api-reference-streaming-data\">STREAMING DATA</h2>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data","title":"STREAMING DATA"},{"content":"<h3 id=\"javascript-api-reference-streaming-data-getstream\">getStream()</h3><p>Continuously stream new updates to a specific JSON document. If you wish to only fetch the existing value, <code>get()</code> is sufficient.</p><p><strong>Usage</strong></p><p><code>appbaseRef.getStream(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the document to be streamed.</p><p><span class=\"fa fa-info-circle\"></span> The <code>streamOnly</code> field parameter is deprecated starting v0.9.0 onwards, and is the default for how <code>getStream()</code> works (previously <code>readStream()</code>).</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><p><code>Note:</code> appbase.js lib uses websockets to stream the updates.</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data-getstream","title":"getStream()"},{"content":"<h3 id=\"javascript-api-reference-streaming-data-searchstream\">searchStream()</h3><p>Continuously stream results of search query on a given <code>type</code>. Search queries can be a variety of things: from simple monitoring queries, finding an exact set of documents, full-text search queries, to geolocation queries.</p><p><code>searchStream()</code> only returns new search results after the query is performed, existing search results can be obtained via <code>search()</code> method.</p><p><strong>Usage</strong></p><p><code>appbaseRef.searchStream(params)</code></p><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code></p><p><span class=\"fa fa-info-circle\"></span> The <code>streamOnly</code> field parameter is deprecated starting v0.9.0 onwards, and is the default for how <code>searchStream()</code> works.</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p>","link":"#/scalr/javascript/api-reference/#javascript-api-reference-streaming-data-searchstream","title":"searchStream()"},{"content":"<h1 id=\"quick-start-to-the-rest-api\">Quick Start to the <img src=\"http://i.imgur.com/a1KAate.png\" alt=\"Scalr\"> REST API:</h1>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api","title":"QUICK START TO THE  REST API:"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for simple username/password authentication. This is similar to how GitHub’s authentication works over <code>https</code>, just imagine every repository (app in our context) having it’s unique &lt;username&gt;:&lt;password&gt; combination.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-0-creating-an-app","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-1-making-requests\">Step 1: Making Requests</h2><p>Here’s an example authenticated <code>GET</code> request. We will set the app name, username and password as bash variables and reuse them in the requests.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-1-making-requests","title":"STEP 1: MAKING REQUESTS"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-1-storing-data\">Step 1: Storing Data</h2><p>Let’s insert a JSON object. We create a <strong>type</strong> <code>books</code> inside our app and add a JSON document <code>1</code> with a PUT request.</p><p>If you have noticed, SCALR uses the same APIs as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-1-storing-data","title":"STEP 1: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data\">Step 2: <s>GETing</s> err, Streaming Data</h2><p>Getting live updates to a document is as simple as suffixing <code>?stream=true</code> to a GET request. It’s so awesome that we recommend using this as the default way to GET things.</p><p>Appbase.io keeps an open connection so that every time there is an update in the <code>/$app/books/1</code> document, it is streamed via the connection.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data","title":"STEP 2: GETING ERR, STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2a-modify-the-document\">Step 2.a: Modify the Document</h3><p>Let’s modify the book price to 6034.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2a-modify-the-document","title":"Step 2.a: Modify the Document"},{"content":"<h3 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2b-observe-the-streams\">Step 2.b: Observe the Streams</h3><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed to the resonse as raw JSON objects. As we see, there are no delimiters between between two consecutive JSON responses.</p><p>For every <code>?stream=true</code> request, Appbase.io keeps an open connection up to a max of 6 hrs.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2b-observe-the-streams","title":"Step 2.b: Observe the Streams"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-3-streaming-search\">Step 3: Streaming Search</h2><p>Streaming document updates seems straightforward, can we apply rich filters and queries to our streams? Yes, we can. We can specify any ElasticSearch Query DSL request, and get responses via streams.</p><p>We will see it here with a <code>match_all</code> query request.</p>","link":"#/scalr/rest/intro/#quick-start-to-the-rest-api-step-3-streaming-search","title":"STEP 3: STREAMING SEARCH"},{"content":"<h1 id=\"datamodel\">Datamodel</h1><p>Appbase is a realtime Database as a Service (DBaaS), built on top of a graph schema with JSON based vertices (similar to JSON documents), and edges to link them.</p><p>All databases support the storing and fetching of data, what distinguishes one database type from another is the structure of the data they store and the means by which it can be retrieved. </p><p>Several popular databases can be classified as below:</p>","link":"#/v2.0/#datamodel","title":"DATAMODEL"},{"content":"<h2 id=\"datamodel-data-in-appbase\">Data in Appbase</h2><p>Appbase is a <a href=\"http://en.wikipedia.org/wiki/Directed_graph\"><em>Directed Graph</em></a>. Objects inside Appbase are called <a href=\"http://en.wikipedia.org/wiki/Vertex_(graph_theory\">Vertices</a>) (a graph term for entities), and the links (relationships) between the objects are called <a href=\"http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Basics\">Edges</a>.</p><p>Data in Appbase is stored as JSON objects. Appbase supports flexible schema, i.e. the properties of the JSON object need not be defined in advance. </p><p>Although Appbase supports storing embedded JSON objects and arrays, one doesn’t have to store data in this denormalized fashion. This is mainly for compatibility with existing document stores like MongoDB. The recommended approach is to create reference links between distint entities. In this doc, we will cover how you can store different kinds data (primitive values, objects, lists), create relationships amongst them, normalize, and do perform different queries on them.</p>","link":"#/v2.0/#datamodel-data-in-appbase","title":"DATA IN APPBASE"},{"content":"<h2 id=\"datamodel-concepts\">Concepts</h2><p>Similar to how SQL has concepts for <em>table</em>, <em>row</em>, <em>column</em>, <em>relation</em> and MongoDB has <em>collection</em> , <em>Document</em> and <em>fields</em>, here are the key concepts in Appbase.</p><p><strong>Vertex</strong> — is similar to a <em>Document</em> in MongoDB, it stores data.  </p><p><strong>Namespace</strong> — is similar to a <em>Collection</em> in MongoDB or <em>type</em> in ElasticSearch. A <em>vertex</em> always belongs to a <em>namespace</em> and <em>security rules</em> can be applied on <em>namespaces</em>. </p><p><strong>Edge</strong> — is a directional link to another vertex.  </p><p>i.e. an <em>edge</em> is pointed from <em>inVertex</em> to an <em>outVertex</em>.</p><p><strong>Path</strong> — Every <em>vertex</em> in Appbase has a path, starting from the &lt;namespace&gt; and ending at the <em>vertex</em>, not unlike the UNIX path. A typical path looks like &lt;namespace&gt;/&lt;v1&gt;/&lt;v2&gt;/…/&lt;vn&gt;/.</p><p><strong>URL</strong> — It is a way to point to a <em>Path</em> in the REST API. Paths are prefixed with the Appbase API base URL, application’s name and the API version. Eg. <a href=\"https://api.appbase.io/chat_app/v2/&lt;path&gt;/\">https://api.appbase.io/chat_app/v2/&lt;path&gt;/</a>.</p><p>We can not actually compare these concepts with other kinds of databases, but it helps to understand Appbase if we compare the <em>usage practices</em>.</p><p>With this table in mind, lets understand how the concepts work.</p>","link":"#/v2.0/#datamodel-concepts","title":"CONCEPTS"},{"content":"<h3 id=\"datamodel-concepts-vertex\">Vertex</h3><p>Vertex is the the standard data container in Appbase. A vertex can store a valid JSON object and be linked to other vertices via <em>edges</em>.</p><p>It can also store nested JSON objects and arrays, but this is only for convenience. In practice, vertices act as singular data entities, i.e. you store only the data relevant to a single entity in the real world. For e.g. a person’s age, name, height, sex can be stored in a single vertex, but the data of his belongings, like a book or a car is a completely different entity. This new entity will have properties of its own and they should be stored inside a new vertex. Later in this document, we will see how we can create a relation between these two entities.</p>","link":"#/v2.0/#datamodel-concepts-vertex","title":"Vertex"},{"content":"<h3 id=\"datamodel-concepts-namespace\">Namespace</h3><p>Namespaces are a way to combine <em>similar</em> entities. For eg. all vertices storing different users can be stored inside the <em>user</em> namespace and all the tweets (repreented as vertices) can be stored inside the <em>tweet</em> namespace. Since namespace is a logical container, different kinds of objects can be stored inside a single namespace. This allows searching for <em>similar vertices</em> and applying <em>security rules</em> with ease.</p><p>Namespaces are <em>searchable</em>. We are using the open-source <a href=\"http://www.elasticsearch.org/\">ElasticSearch</a> behind the scenes to support this use-case. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for a quick intro on how search works.</p>","link":"#/v2.0/#datamodel-concepts-namespace","title":"Namespace"},{"content":"<h3 id=\"datamodel-concepts-edge-one-to-one-relationships\">Edge (one-to-one relationships)</h3><p>After creating entities, its time to create relations amongst them via <em>edges</em>. </p><p>An edge is a <em>named</em> directional link connecting two vertices for a purpose, a <em>one-to-one relation</em>. For instance, a book has an author, a husband has wife and a child has a mother. The edges for these would be <em>book vertex</em> <code>--authouredBy-&gt;</code> <em>person vertex</em>, <em>man vertex</em> <code>--marriedTo-&gt;</code> <em>woman vertex</em>. </p><p>Edges are directional, so if you set the edge <em>man</em> <code>--marriedTo-&gt;</code> <em>woman</em>, it only tells us that the man is married to the woman, but it tells us nothing about woman’s relationship status. For that, another edge, <em>woman</em> <code>--marriedTo-&gt;</code> <em>man</em>, should be created.</p><p>Appbase only allows for unique edge names. The default behaviour is last-write-wins in case a new edge is created with an existing name. Edges have priorities which are rational numbers (think of the <code>Number</code> datatype in Javascript).</p>","link":"#/v2.0/#datamodel-concepts-edge-one-to-one-relationships","title":"Edge (one-to-one relationships)"},{"content":"<h3 id=\"datamodel-concepts-path\">Path</h3><p>Paths are the way to interact with vertices in Appbase. Paths are constructed with &lt;namespace&gt;/&lt;vertexKey&gt;/&lt;edgeName_1&gt;/…/&lt;edgeName_N&gt;/.</p><p>Creating edges create deeper <em>Paths</em>. Lets take the example of the movie Inception, the Oscar deserver lead actor Leonardo DiCaprio, and the director Christopher Nolan. Here are the vertices stored in Appbase:</p><p>These vertices can be accessed with the following paths, as entry points in the graph:</p><p>Let’s create edges:</p><p><img src=\"http://i.imgur.com/2Asfr9r.png\" alt=\"\"></p><p>With these edge, we created these deeper paths:</p><p><code>movie/inception/leadActor</code> : points to the same vertex as <code>person/dicaprio</code></p><p><code>movie/inception/directedBy</code> : points to <code>person/nolan</code></p><p><code>person/nolan/marriedTo</code>: points to <code>person/emma</code></p><p>Here’s the <em>magic</em>, the path <code>movie/inception/directedBy/marriedTo</code> points directly to <code>person/emma</code></p><p>This means, modifying the data stored at <code>movie/inception/directedBy/marriedTo</code> will change the data of <code>person/emma</code> as they both are the same vertices.</p><p>Paths are powerful ways to point to the exact data you want to interact with. For e.g.  when you access the path <code>movie/inception/directedBy/marriedTo</code>, you are only interested in the vertex representing the person who is married to the director of Inception, and nothing else. You never access the data of the movie Inception, or the director.</p>","link":"#/v2.0/#datamodel-concepts-path","title":"Path"},{"content":"<h3 id=\"datamodel-concepts-url\">URL</h3><p>A URL is just another representation of a <em>Path</em>. REST API URL looks like this: <a href=\"https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/\">https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/</a>. </p><p>Assuming the Application’s name as <em>imdb</em>, URL for the path <em>movie/inception/directedBy/marriedTo</em> would be <code>https://api.appbase.io/imdb/v2/movie/inception/directedBy/marriedTo</code></p>","link":"#/v2.0/#datamodel-concepts-url","title":"URL"},{"content":"<h2 id=\"datamodel-storing-data\">Storing Data</h2><p>Being a Graph, Appbase allows you to create any kind of data structures you want, you just need to know exactly how. Lets see how to store the practical data structures we used on daily basis.</p><p>The examples here use Appbase Javascript Library and if any of the method is confusing you, feel free to chekout the <a href=\"http://docs.appbase.io/#/v2.0/javascript/api-reference\">JS Documentation</a>.</p>","link":"#/v2.0/#datamodel-storing-data","title":"STORING DATA"},{"content":"<h3 id=\"datamodel-storing-data-primitive-data-and-json-objects\">Primitive Data and JSON Objects</h3><p>Numbers, Characters, Strings and Booleans, are stored as values of the properties inside a vertex. Dates can be converted into the milliseconds since epoch, and store them as Numbers. For eg. you want to store a the movie’s name, and its release year, you can store combine all of them as a JSON object and store it inside a vertex.</p>","link":"#/v2.0/#datamodel-storing-data-primitive-data-and-json-objects","title":"Primitive Data and JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-nested-json-objects\">Nested JSON Objects</h3><p>You can store nested objects directly inside a vertex. E.g.</p><p>This would work perfectly. Notice that you are not storing the director (Nolan) of Inception as a <em>different entity</em>, instead as a <em>property</em> of the movie itself. While this approach is sometimes handy, it limits you in terms of what you can do with Nolan. I.e. you will not be able to establish any direct relationships with Nolan, as it is not an entity in itself. For eg. Nolan is married to Emma, but there is no way to create a link between Nolan  and Emma, when it is stored as a nested object in Appbase.</p><p>A better to do this is store Nolan as a new vertex, and create an edge from Inception to Nolan. You can create another vertex for Emma create edges with Nolan. </p><p>We will create three edges here: </p><p>inception <code>--directedBy-&gt;</code> nolan</p><p>nolan <code>--marriedTo-&gt;</code> emma\nRecall that the edges are <em>directional</em>, so this 2nd edge only tells us that Nolan in married to Emma, but says nothing about Emma’s marital status. That’s why we create the third edge: </p><p>emma <code>--marriedTo-&gt;</code> nolan</p><p><img src=\"http://i.imgur.com/IipHJzL.png\" alt=\"\"></p><p>Notice that Inception directed by Nolan, is a One-to-One relationship. Nolan has directed many movies, and that’s a case of One-to-Many relationships. We see later how to create them in Appbase. </p>","link":"#/v2.0/#datamodel-storing-data-nested-json-objects","title":"Nested JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-sets-one-to-many-relationship\">Sets (One-to-Many Relationship)</h3><p>A set makes sure that all the items in the list exist only once. Consider this example, the movies directed by Nolan. We will make only a small list here:  <code>[\"Interstellar\", \"Inception\", \"The Dark Night\", \"Memento\"]</code>. Clearly, it doesn’t make sense to have any of the movies twice in the this list.  Notice that this is a One-to-Many relationship here. <em>Nolan</em> (1) -&gt; <em>Movies</em> (N).</p><p>Operations on a single set are: addition, checking existence of an item, deletion and traversal. </p><p>Operations on multiple sets, like union and intersection can be emulated using single-set operations. For e.g.</p><p>Let’s see a practical set, the movies directed by Nolan. </p><p>In Appbase, the Set is a vertex, let’s create it.</p><p>Also the Items in the set are vertices.</p><p>Now we have Appbase Vertex References to the Set and the Items, lets go through different set operations.</p><p>Simply creating an edge from the Set to the Item. We will use the Primary Key (<code>inceptionRef.name()</code>) of the item as the name of the edge.</p><p>Here, the important thing is to keep the edge-name exactly as the Vertex Key. That way makes sure that every item will exist only once in the set. For e.g. if you try to add <code>inceptionRef</code> again in the set, it will just replace the old edge no extra edges will be created.</p><p>Keeping the edge-name same as the Vertex Key of the item, allows other operations as well, like deletion of an Item and checking where an Item exists.</p><p>Remove the edge from Set to the Item.</p><p>As we kept the edge name exactly as the Vertex Key, it means that we can use the Vertex Key to delete the edge as well.</p><p>It’s not possible to check via the Item’s data, if the item exists or not. The only way we can check, is using the Vertex Key/edge-name. We see that if there’s an edge, with its name as the Vertex Key. We use <code>outVertex()</code> and <code>isValid()</code> for that. I.e. we are checking if the path <code>set/moviesByNolan/&lt;movieVertexKey&gt;</code> is valid or not.</p><p>As all the items are the edges of the Set vertex, we simply fetch the edges of the Set vertex, and traverse through them.</p><p>See <em>Retrieving Data</em> section.</p>","link":"#/v2.0/#datamodel-storing-data-sets-one-to-many-relationship","title":"Sets (One-to-Many Relationship)"},{"content":"<h2 id=\"datamodel-retrieving-data\">Retrieving Data</h2><p>In a nutshell, Namspaces in Appbase have vertices, and vertices have properties, edges.</p><p>Data retrieval in Appbase happens via <em>realtime streams</em>. These streams allows you to fetch existing data, and then keep listening to new data as well.</p>","link":"#/v2.0/#datamodel-retrieving-data","title":"RETRIEVING DATA"},{"content":"<h3 id=\"datamodel-retrieving-data-properties\">Properties</h3><p>When you start listening to the properties of a vertex, you first get the existing properties, and then as the data keeps changing, the callback is called again with new properties.</p><p>Appbase gives you the properties data as a <em>snapshot</em>. The snapshots are immutable copies of the data stored in a vertex. Any changes you make in the snapshot will not be stored in Appbase. </p><p>If you don’t want to listen to the properties any more, you can turn the listener off with <code>inceptionRef.off()</code>.</p><p>For convenience, we have the method  <code>inceptionRef.once()</code> when you want to listen to daat just only once.</p>","link":"#/v2.0/#datamodel-retrieving-data-properties","title":"Properties"},{"content":"<h3 id=\"datamodel-retrieving-data-edges\">Edges</h3><p>Retrieving existing edges of a vertex is simple: just listen to <em>edge_added</em> event, which will return existing edges at first. When new edges are added, the callback will be fired for new edges as well.</p><p>Notice that the if there are ‘N’ number of existing edges, the callback will be called ‘N’ times.</p><p><code>eRef</code> here is the Appbase Reference to the outVertex, and <code>eSnap</code> is the snapshot of the edge. Edge Snapshot is the snapshot of the data stored with the edge and the out vertex, mainly the <em>priority</em> of the edge, and the properties of the out vertex. <code>eSnap.priority()</code> will give you the priority, and <code>eSnap.properties()</code> will give you properties.</p><p>With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them, or want to fetch only a particular edge.</p><p>When more than one filter is provided, they work as logical <code>AND</code> and only the edges matchihg all filters will be fetched. This is what each filter means:</p><p>Notice that:\n - Filters are a way to fetch existing edges, thus they work only with <em>edge_added</em> event\n - Edges are always returned ordered according to their priorities\n - When <em>endAt</em> &lt; <em>startAt</em>, edges are returned in reverse order\n - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime\n    - This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code>\n    - <em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</p>","link":"#/v2.0/#datamodel-retrieving-data-edges","title":"Edges"},{"content":"<h3 id=\"datamodel-retrieving-data-vertices-in-a-namespace\">Vertices in a Namespace</h3><p>Namespaces are vertex containers, and it is possible to retrieve existing vertices, and listen to updates when new vertices are added or old vertices are removed.</p><p>The callback attached with <em>vertex_added</em> event is called for all the existing vertices. As new vertices are added, it is called for them too.</p><p>To listen to updates of vertex removal, use <em>vertex_removed</em> event.</p><p>With ElasticSearch’s powerful APIs in the backend, Appbase supports full-text fuzzy search queries on the data stored into vertices of a namespace. A sample query on a namespace looks something like this: </p><p>This query searches on all the vertices of the namespace <em>movie</em>, and returns an array of vertices who’s property <code>year</code>, matches fuzzily with the text “2010”. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for more details.</p>","link":"#/v2.0/#datamodel-retrieving-data-vertices-in-a-namespace","title":"Vertices in a Namespace"},{"content":"<h1 id=\"major-changes\">Major changes</h1>","link":"#/v3.0/changelog/changelog/#major-changes","title":"MAJOR CHANGES"},{"content":"<h3 id=\"major-changes-1-json-document-based-model\">1. JSON Document based Model</h3><p>With v3.0, Appbase adopts the JSON based document schema model (similar to MongoDB and ElasticSearch). We are bringing the simplicity of JSON based data models to Appbase with this major revision while still maintaining index-free adjency references for each document.</p><p>Here’s how the mapping works if you are familiar with the v2.0 API:</p>","link":"#/v3.0/changelog/changelog/#major-changes-1-json-document-based-model","title":"1. JSON Document based Model"},{"content":"<h3 id=\"major-changes-2-rest-api-format\">2. REST API Format</h3><p>The overall API format has been made more expressive.</p>","link":"#/v3.0/changelog/changelog/#major-changes-2-rest-api-format","title":"2. REST API Format"},{"content":"<h1 id=\"datamodel\">Datamodel</h1>","link":"#/v3.0/concepts/datamodel/#datamodel","title":"DATAMODEL"},{"content":"<h2 id=\"datamodel-data-in-appbase\">Data in Appbase</h2>","link":"#/v3.0/concepts/datamodel/#datamodel-data-in-appbase","title":"DATA IN APPBASE"},{"content":"<h2 id=\"datamodel-understanding-data\">Understanding Data</h2>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data","title":"UNDERSTANDING DATA"},{"content":"<h3 id=\"datamodel-understanding-data-document\">Document</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data-document","title":"Document"},{"content":"<h3 id=\"datamodel-understanding-data-collection\">Collection</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data-collection","title":"Collection"},{"content":"<h3 id=\"datamodel-understanding-data-reference\">Reference</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data-reference","title":"Reference"},{"content":"<h3 id=\"datamodel-understanding-data-path\">Path</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data-path","title":"Path"},{"content":"<h3 id=\"datamodel-understanding-data-url\">URL</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-understanding-data-url","title":"URL"},{"content":"<h2 id=\"datamodel-saving-data\">Saving Data</h2>","link":"#/v3.0/concepts/datamodel/#datamodel-saving-data","title":"SAVING DATA"},{"content":"<h3 id=\"datamodel-saving-data-writing-data\">Writing Data</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-saving-data-writing-data","title":"Writing Data"},{"content":"<h3 id=\"datamodel-saving-data-modifying-data\">Modifying Data</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-saving-data-modifying-data","title":"Modifying Data"},{"content":"<h2 id=\"datamodel-retrieving-data-and-queries\">Retrieving Data and Queries</h2>","link":"#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries","title":"RETRIEVING DATA AND QUERIES"},{"content":"<h3 id=\"datamodel-retrieving-data-and-queries-retrieving-document-properties\">Retrieving Document Properties</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-retrieving-document-properties","title":"Retrieving Document Properties"},{"content":"<h3 id=\"datamodel-retrieving-data-and-queries-references\">References</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-references","title":"References"},{"content":"<h3 id=\"datamodel-retrieving-data-and-queries-streaming-vs-retrieval\">Streaming vs Retrieval</h3>","link":"#/v3.0/concepts/datamodel/#datamodel-retrieving-data-and-queries-streaming-vs-retrieval","title":"Streaming vs Retrieval"},{"content":"<h1 id=\"security\">Security</h1>","link":"#/v3.0/concepts/datamodel/#security","title":"SECURITY"},{"content":"<h2 id=\"security-serverside\">Serverside</h2>","link":"#/v3.0/concepts/datamodel/#security-serverside","title":"SERVERSIDE"},{"content":"<h3 id=\"security-serverside-app-secret\">App Secret</h3>","link":"#/v3.0/concepts/datamodel/#security-serverside-app-secret","title":"App Secret"},{"content":"<h2 id=\"security-clientside\">Clientside</h2>","link":"#/v3.0/concepts/datamodel/#security-clientside","title":"CLIENTSIDE"},{"content":"<h1 id=\"acidity\">ACIDity</h1>","link":"#/v3.0/concepts/datamodel/#acidity","title":"ACIDITY"},{"content":"<h1 id=\"performance\">Performance</h1>","link":"#/v3.0/concepts/datamodel/#performance","title":"PERFORMANCE"},{"content":"<h1 id=\"searching-for-a-better-search\">Searching for a better Search?</h1><p>Building a good quality full-text search experience for an app is a hard problem if your data resides in traditional RDBMS systems. Even database systems like MongoDB have very nascent support for search, others like DynamoDB offer no support. The hard, real fact is that these systems are not designed with search as a use-case, and one is left with a very rudimentary support like exact search match, or in the worst case scenario, even scanning the DB tables.</p><p>While there are great tools available for search, like Apache Solr and Elasticsearch, they have two big problems:<br>1. It is not recommended to use ElasticSearch as a primary data store. So you are still stuck with the problem of streaming data from your primary store to a search database like ES.<br>2. The documentation is intimidating. Really, it seems the docs are made for rocket scientists rather than your average app developer!</p><p>We have thought about the <strong>Search</strong> problem really hard, and have come up with an elegant solution.</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search","title":"SEARCHING FOR A BETTER SEARCH?"},{"content":"<h2 id=\"searching-for-a-better-search-our-approach-to-search\">Our Approach to Search</h2><p>Appbase takes the search problem head-on and indexes all the data that is ever stored in Appbase, allowing searching on all the data and relationships. We provide the ability to do the following kind of queries:<br>1. Full-text search - including <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-simple-match-and-fulltext\">simple match queries</a>, <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-fulltext-fuzzy\">fuzzy search queries</a>, and <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-fulltext-autocompletewildcard\">autocomplete</a>\n2. <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-numeric-range\">Numeric-range queries</a> - when you want answers to “Give me all the products that cost between $50 and $100” or “fetch all pages from 5 to 10”,<br>3. <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-geo-spatial\">Geo spatial queries</a> - ElasticSearch offers a lot of Geo Spatial queries. To name a few, you can compare distances, get a bounding box, determine shape,<br>4. <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-sorting\">Sort queries</a> - sort queries are more like filters to arrange data returned by one of above queries. You can sort the data using multiple “property” parameters.</p><p>With <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-aggregation\">Aggregation</a> and <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-combining-queriesfilters\">Combining queries</a>, the possibilities are endless.</p><p>Here’s a primer to leverage these powerful search queries broken into three steps.</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search","title":"OUR APPROACH TO SEARCH"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-1-create-an-app\">1. Create an App</h3><p>Log into <span class=\"fa fa-external-link\"></span><a href=\"https://appbase.io/developer/\">Appbase Dashboard</a>, and create a new app. Once you create an app with a desired name, you should see an app dialog box appear as below.</p><p><img src=\"https://dl.dropboxusercontent.com/spa/q0230upf0vj6xe0/snvrcs_y.png\" alt=\"App credentials\"><br><strong>Image 1</strong>: App name, stats and credentials</p><p>Click the <img src=\"https://dl.dropboxusercontent.com/spa/q0230upf0vj6xe0/jf22g2ed.png\" alt=\"Icon\"> icon to copy your secret into clipboard.</p><p>We will need the <code>app name</code> and the <code>secret</code> in all our API calls. In this case, these would be <em>my_app9</em> and <em>097b2b28b6a13cf2e53b6cecfec42b86</em>. We <strong>trust you</strong> with our app’s secret!</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-1-create-an-app","title":"1. Create an App"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-2-store-some-data\">2. Store some Data</h3><p>Appbase supports the document data model. You can store JSON objects (known as documents) with Appbase directly (similar to MongoDB documents, or RDBMS records). The documents are stored within a collection. Appbase supports a granular search which typically works on a collection. The search is based on the <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/1.x/query-dsl.html\">ElasticSearch DSL</a>, and supports the entire query format.</p><p>For brevity, let’s say we are storing user profiles that we would like to later search by different document properties. Here’s how a JSON user object might look:</p><p>To store this data with Appbase, we will make a <em>PATCH</em> request via REST. You can read more about them in our <a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-properties-create-update-document-properties\">REST API</a>. Here’s how the request would like in our case:</p><p>When you copy the above code, be sure to replace the <code>Appbase-Secret</code> header and the <code>app name</code> in the URL to match your credentials.</p><p><em>Understanding the Request</em></p><p>To store data, we do a <strong>PATCH</strong> request.</p><p>URL: <a href=\"https://v3.api.appbase.io/my_app9/people/laura/~properties\">https://v3.api.appbase.io/my_app9/people/laura/~properties</a>, where</p><p>Headers<br>Headers in this request include the <code>Appbase-Secret</code> value.</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-2-store-some-data","title":"2. Store some Data"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data\">3. Perform Search on Data</h3><p>Now that we have successfully stored data, let’s perform a full-text search.</p><p>Let’s search for users whose occupation is being a <em>designer</em>.</p><p>The response that you get from Appbase is an array of JSON objects which match the query criteria.</p><p>Response:</p><p>There you go! Appbase’s search fetches results which are close to the search term, and you get the following object in response.</p><p><em>Understanding the Request</em></p><p>To perform a search, we do a <strong>POST</strong> request.</p><p>URL: <a href=\"https://v3.api.appbase.io/my_app9v/people/~search\">https://v3.api.appbase.io/my_app9v/people/~search</a>, where</p><p>Request Headers<br>Headers are always the same for all REST API requests.</p><p>Request Body<br>The JSON query object that we send with this request:</p><p>That’s it! In less than 10 minutes, we were able to add production grade search in your app.</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data","title":"3. Perform Search on Data"},{"content":"<h2 id=\"searching-for-a-better-search-full-text-and-more\">Full text and more</h2><p>Do you want to customize the ‘fuzziness’ of your search? Or perhaps apply multiple queries and filter the data at the same time. If this has whetted your appetite, check out our main article over here. <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases\">Search Usecases</a>.</p>","link":"#/v3.0/search/quick-start/#searching-for-a-better-search-full-text-and-more","title":"FULL TEXT AND MORE"},{"content":"<h1 id=\"appbasejs\">appbase.js</h1><p>JavaScript Wrapper for Appbase Rest API</p>","link":"#/v3.0/javascript/api-reference/#appbasejs","title":"APPBASE.JS"},{"content":"<h2 id=\"appbasejs-1-appbase-global-object\">1. Appbase Global Object</h2><p>The Appbase object is responsible for instantiating Apps.</p>","link":"#/v3.0/javascript/api-reference/#appbasejs-1-appbase-global-object","title":"1. APPBASE GLOBAL OBJECT"},{"content":"<h3 id=\"appbasejs-1-appbase-global-object-methods\">Methods</h3><p><strong>Appbase.app(appname, secret)</strong><br>Used to create a new instance of a App<br>Parameters:</p>","link":"#/v3.0/javascript/api-reference/#appbasejs-1-appbase-global-object-methods","title":"Methods"},{"content":"<h2 id=\"appbasejs-2-app-class\">2. App Class</h2><p>The App class has utility methods to manage the App’s collections.</p>","link":"#/v3.0/javascript/api-reference/#appbasejs-2-app-class","title":"2. APP CLASS"},{"content":"<h3 id=\"appbasejs-2-app-class-methods\">Methods</h3><p> <strong>App.search(query)</strong><br>This method searches the App’s collections with the given query.<br><a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-global-search-collections\">View in the REST API Docs</a><br>Parameters:  </p><p> Example</p><p>  <strong>AppTest.listCollections()</strong><br>This method retrieves all the collections of the app.<br><a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-global-list-collections\">View in the REST API Docs</a>  </p><p><strong>AppTest.serverTime()</strong><br>Returns the server timestamp in milliseconds.<br><a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-global-server-time\">View in the REST API Docs</a>  </p><p><strong>AppTest.collection(name)</strong><br>Returns a Collection object for the provided name  </p><p>Parameters:  </p>","link":"#/v3.0/javascript/api-reference/#appbasejs-2-app-class-methods","title":"Methods"},{"content":"<h2 id=\"appbasejs-3-collection-class\">3. Collection Class</h2><p>Provides an interface to the Appbase’s REST endpoints to manage your collections.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference\">View in the REST API Docs</a></p>","link":"#/v3.0/javascript/api-reference/#appbasejs-3-collection-class","title":"3. COLLECTION CLASS"},{"content":"<h2 id=\"appbasejs-properties\">Properties</h2>","link":"#/v3.0/javascript/api-reference/#appbasejs-properties","title":"PROPERTIES"},{"content":"<h2 id=\"appbasejs-methods\">Methods</h2><p><strong>collection.search(query)</strong>\nSearches the collection’s documents with the provided query.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-collection-search-documents-by-propertyies\">View in the REST API Docs</a><br>Parameters:  </p><p><strong>collection.insert(entry)</strong>\nCreate a new document in the collection\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-properties-create-update-document-properties\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.set(key, entry)</strong>\nCreate or update a new document in the collection, with the provided key as the id of that object.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-properties-create-update-document-properties\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.unset(key, properties)</strong>\nDelete specific (or all) data properties of a document.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-properties-delete-document-properties\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.get(key)</strong>\nRead the existing document properties.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-properties-read-document-properties\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.getAll([filters])</strong>\nList the documents in the collection. Returns an array of documents in the given collection.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-collection-list-all-documents\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.on(key, callback[, errorCallback])</strong>\nListen to changes on the Document with the provided key.</p><p>Parameters:  </p><p><strong>collection.onDocuments(callback[, errorCallback])</strong>\nListen to the creation or changes on any Document in the collection.</p><p>Parameters:  </p><p><strong>collection.onRef(key, callback[, errorCallback])</strong>\nListen to the creation or changes of References on the Document that has the provided key.</p><p>Parameters:  </p><p><strong>collection.setRef(key, ref, path[, priority])</strong>\nListen to the creation or changes of References on the Document that has the provided key.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-references-create-update-document-references\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.getRefs(key[, filters])</strong>\nGet all the References of the Document with the provided key.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-references-read-references\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.unsetRefs(key, references)</strong>\nRemoves the provided References from the Document with the provided key.\n<a href=\"http://docs.appbase.io/#/v3.0/rest/api-reference#api-reference-document-references-delete-references\">View in the REST API Docs</a></p><p>Parameters:  </p><p><strong>collection.delete(key)</strong>\nRemoves the Document with the provided key from the collection.</p><p>Parameters:  </p>","link":"#/v3.0/javascript/api-reference/#appbasejs-methods","title":"METHODS"},{"content":"<h1 id=\"ng-appbase-guide\">ng-Appbase Guide</h1><p>Appbase provides a realtime graph backend, is designed to write complex applications completely clientside. Appbase fits perfectly as a backend in your AngularJS application.</p><p>ngAppbase - AngularJS binding for Appbase, makes it very simple to bind your data between AngularJS and Appbase backend.</p><p><a href=\"http://appbase.io/tutorial.html\">Here</a>‘s a quick tutorial for Appbase JS api.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide","title":"NG-APPBASE GUIDE"},{"content":"<h2 id=\"ng-appbase-guide-integrating-the-awesome\">Integrating the awesome</h2><p>Add these script tags in your HTML:</p><p>Register <code>ngAppbase</code> as a dependency in the module, and the <code>$appbase</code> is available to be injected into any controller, service, or factory.</p><p><code>$appbase</code>, has the same methods as <code>Appbase</code> object exposed by the Appbase Javascript library. The difference is, when Appbase refrences (namespace and vertex) are created using <code>$appbase</code>, they have extra methods which allows binding your data with scope variables in Angular.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-integrating-the-awesome","title":"INTEGRATING THE AWESOME"},{"content":"<h2 id=\"ng-appbase-guide-binding-objects\">Binding Objects</h2><p>As Angular binds the data between JS models and the DOM, ngAppbase propagates any changes the data from Appbase. This way, any changes to Appbase automatically appears in the DOM.\nNotice that, the changes in the JS model are <em><strong>not</strong></em> automatically sent to Appbase backend.</p><p><code>bindProperties</code> creates such a synchronized object, by binding properties of a vertex in Appbase, to a variable in JS.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-binding-objects","title":"BINDING OBJECTS"},{"content":"<h3 id=\"ng-appbase-guide-binding-objects-example\">Example:</h3><p>Assume the properties of the vertex at <strong>‘user/bella’</strong> : </p><p>To bind this data to your view,\nJS:</p><p>HTML:</p><p>As Appbase notifies for data changes in realtime, if the data at <strong>‘user/bella’</strong> changes, i.e. if <code>$appbase.ns('user').v('bella').setData({having: 'Cerveja'})</code> is called, this change will be reflected in the scope variable instantly, and Angular will update the view.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-binding-objects-example","title":"Example:"},{"content":"<h2 id=\"ng-appbase-guide-binding-arrays\">Binding Arrays</h2><p><code>ng-repeat</code> in AngularJS binds a list in DOM to an array model in JS, and this array can be bound to the <em>edges</em> of a <strong>vertex</strong>, or <em>vertices</em> in a <strong>namespace</strong> in Appbase, using <code>bindEdges</code> and <code>bindVertices</code>.</p><p>When edges or vertices are added, removed, replaced, or the priority is changed, these changes appear in the DOM in realtime.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-binding-arrays","title":"BINDING ARRAYS"},{"content":"<h3 id=\"ng-appbase-guide-binding-arrays-example\">Example</h3><p>Data in the out vertex pointed by the edge:</p><p>To bind this data into you view:\nJS:</p><p>HTML:</p><p>The same way, you can bind vertices under a namespace, as an array.</p><p>JS:</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-binding-arrays-example","title":"Example"},{"content":"<h2 id=\"ng-appbase-guide-modifying-data\">Modifying data</h2><p>Vertex References created with <code>$appbase.ns().v()</code> has all the methods exactly as the Appbase Javascript API. You can use methods <code>setData()</code> and <code>setEdge()</code> to modify the data.</p><p>The  documentation for Appbase JS api is <a href=\"http://docs.appbase.io/docs/js.html\">here</a>.</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-modifying-data","title":"MODIFYING DATA"},{"content":"<h2 id=\"ng-appbase-guide-next-steps\">Next Steps</h2><p>Checkout additional documentation for <code>bindEdges()</code>, <code>bindVertices()</code> and <code>bindProperties()</code> further down on this page.</p><p>Checkout this opensource <a href=\"http://twitter.appbase.io/\">Twitter clone</a> we built using this Angular binding in under ~250 lines of javascript code.</p><p>Have a great time building awesome realtime applications!</p>","link":"#/v2.0/javascript/angular/#ng-appbase-guide-next-steps","title":"NEXT STEPS"},{"content":"<h1 id=\"appbase-api-docs\">$appbase API Docs</h1>","link":"#/v2.0/javascript/angular/#appbase-api-docs","title":"$APPBASE API DOCS"},{"content":"<h2 id=\"appbase-api-docs-vertexrefbindedges\">vertexRef.bindEdges()</h2>","link":"#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges","title":"VERTEXREF.BINDEDGES()"},{"content":"<h3 id=\"appbase-api-docs-vertexrefbindedges-returns\">Returns</h3><p>An <strong>array</strong> of edges, <em>sorted</em> by the <strong>priority</strong> of edges.\nEach object (called <em>edgeData</em> from now on) in array represents an edge and contains this data:</p>","link":"#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges-returns","title":"Returns"},{"content":"<h3 id=\"appbase-api-docs-vertexrefbindedges-arguments\">Arguments</h3><p>Note that the vertex references returned in the callback, also have the methods <code>bindProperties</code> and <code>bindEdges</code>. Using <code>onAdd</code> callback and these methods, you can bind multiple level of edges.</p><p>Eg.</p>","link":"#/v2.0/javascript/angular/#appbase-api-docs-vertexrefbindedges-arguments","title":"Arguments"},{"content":"<h2 id=\"appbase-api-docs-bindvertices\">bindVertices()</h2><p><code>bindVertices</code> works exactly as <code>bindEdges</code>, except that it is invoked on a namespace reference and returns an array of all the vertices in the namespace. Callbacks <em>onAdd</em>, <em>onRemove</em> and <em>onChange</em> are called, respectively, when a vertex is added, destroyed and properties are changed. <em>onComplete</em> is called when existing vertices are retrieved. Works exactly as <code>onComplete</code> callback for <em>vertex_added</em> event in Appbase Javascript Library.</p>","link":"#/v2.0/javascript/angular/#appbase-api-docs-bindvertices","title":"BINDVERTICES()"},{"content":"<h2 id=\"appbase-api-docs-bindproperties\">bindProperties()</h2>","link":"#/v2.0/javascript/angular/#appbase-api-docs-bindproperties","title":"BINDPROPERTIES()"},{"content":"<h3 id=\"appbase-api-docs-bindproperties-returns\">Returns</h3><p>An <strong>object</strong> , containing <em>properties</em> of the vertex as key-value pairs.</p>","link":"#/v2.0/javascript/angular/#appbase-api-docs-bindproperties-returns","title":"Returns"},{"content":"<h3 id=\"appbase-api-docs-bindproperties-arguments\">Arguments</h3>","link":"#/v2.0/javascript/angular/#appbase-api-docs-bindproperties-arguments","title":"Arguments"},{"content":"<h1 id=\"introduction\">Introduction</h1><p>The Appbase API is based on REST principles. All operations including creation of new documents and references, fetching document (JSON) and references, deleting a document or a reference as well as searching through documents are RESTful.</p>","link":"#/v3.0/rest/api-reference/#introduction","title":"INTRODUCTION"},{"content":"<h3 id=\"introduction-resource-types\">Resource Types</h3>","link":"#/v3.0/rest/api-reference/#introduction-resource-types","title":"Resource Types"},{"content":"<h3 id=\"introduction-allowed-http-request-types\">Allowed HTTP Request Types</h3>","link":"#/v3.0/rest/api-reference/#introduction-allowed-http-request-types","title":"Allowed HTTP Request Types"},{"content":"<h3 id=\"introduction-authorization\">Authorization</h3><p>Appbase accepts one of the two methods of authorizations.</p><p>In this document, we will be using the 1. method since it makes authorization distinct from the request data.</p>","link":"#/v3.0/rest/api-reference/#introduction-authorization","title":"Authorization"},{"content":"<h3 id=\"introduction-base-uri\">Base URI</h3><p>Base URI is the fixed URI that is common for all the API request endpoints and is prefix to all the API requests. A base URI has two path variables: <strong>appname</strong> and <strong>api_version</strong>. A typical base URI looks like <a href=\"https://v3.api.appbase.io/&lt;appname&gt;/\">https://v3.api.appbase.io/&lt;appname&gt;/</a>.</p>","link":"#/v3.0/rest/api-reference/#introduction-base-uri","title":"Base URI"},{"content":"<h1 id=\"api-reference\">API Reference</h1>","link":"#/v3.0/rest/api-reference/#api-reference","title":"API REFERENCE"},{"content":"<h2 id=\"api-reference-introduction\">Introduction</h2><p>The Appbase API endpoints are divided between three types of different resources.</p><p>A path consists of a document and one or more references. It’s similar to how symlinks work in *nix filesystems.</p>","link":"#/v3.0/rest/api-reference/#api-reference-introduction","title":"INTRODUCTION"},{"content":"<h2 id=\"api-reference-global\">Global</h2>","link":"#/v3.0/rest/api-reference/#api-reference-global","title":"GLOBAL"},{"content":"<h3 id=\"api-reference-global-server-time\">Server Time</h3><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-global-server-time","title":"Server Time"},{"content":"<h3 id=\"api-reference-global-list-collections\">List collections</h3><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-global-list-collections","title":"List collections"},{"content":"<h3 id=\"api-reference-global-search-collections\">Search collections</h3><p>Search documents across one or more collections. <em>Returns</em> a JSON body matching the <strong>ElasticSearch response format</strong>. The matching search results are inside the <code>hits.hits</code> field as an array of documents. For more details, see <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases\">more queries</a> that can be done with this endpoint, including fuzzy search, numeric-range, geospatial and aggregation queries.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-global-search-collections","title":"Search collections"},{"content":"<h2 id=\"api-reference-collection\">Collection</h2>","link":"#/v3.0/rest/api-reference/#api-reference-collection","title":"COLLECTION"},{"content":"<h3 id=\"api-reference-collection-list-all-documents\">List all documents</h3><p>List the documents in the collection. <em>Returns</em> an array of documents in the given collection.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-collection-list-all-documents","title":"List all documents"},{"content":"<h3 id=\"api-reference-collection-search-documents-by-propertyies\">Search Documents by property(ies)</h3><p>Search documents by one or more document properties. <em>Returns</em> a JSON body matching the <strong>ElasticSearch response format</strong>. The matching search results are inside the <code>hits.hits</code> field as an array of documents. For more details, see other queries that can be done with this <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases\">endpoint</a>, including fuzzy search, numeric-range, geospatial and aggregation queries.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-collection-search-documents-by-propertyies","title":"Search Documents by property(ies)"},{"content":"<h2 id=\"api-reference-document-properties\">Document Properties</h2><p>All data operations on a document happen via <strong>Document Properties</strong> endpoint.</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-properties","title":"DOCUMENT PROPERTIES"},{"content":"<h3 id=\"api-reference-document-properties-create-update-document-properties\">Create / Update Document Properties</h3><p>Create a new document with some properties or update the properties of an existing document.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-properties-create-update-document-properties","title":"Create / Update Document Properties"},{"content":"<h3 id=\"api-reference-document-properties-read-document-properties\">Read Document Properties</h3><p>Read the existing document properties.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-properties-read-document-properties","title":"Read Document Properties"},{"content":"<h3 id=\"api-reference-document-properties-delete-document-properties\">Delete document properties</h3><p>Delete specific (or all) data properties of a document.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-properties-delete-document-properties","title":"Delete document properties"},{"content":"<h2 id=\"api-reference-document-references\">Document References</h2>","link":"#/v3.0/rest/api-reference/#api-reference-document-references","title":"DOCUMENT REFERENCES"},{"content":"<h3 id=\"api-reference-document-references-create-update-document-references\">Create / Update Document References</h3><p>Create a new reference or update the existing reference(s). A <strong>priority</strong>, which acts as an index can optionally be set on the reference.</p><p><strong>Example Request</strong>  </p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-references-create-update-document-references","title":"Create / Update Document References"},{"content":"<h3 id=\"api-reference-document-references-read-references\">Read References</h3><p>Fetch the document references.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-references-read-references","title":"Read References"},{"content":"<h3 id=\"api-reference-document-references-delete-references\">Delete References</h3><p>Delete specific (or all) document references.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-document-references-delete-references","title":"Delete References"},{"content":"<h2 id=\"api-reference-delete-document\">Delete Document</h2><p>Deletes the document (including all properties, references), the document path itself will not resolve after this operation, i.e. a retrieval will result in a <em>101: Resource does not exist</em> error.</p><p><strong>Example Request</strong></p><p><strong>Usage</strong>:</p>","link":"#/v3.0/rest/api-reference/#api-reference-delete-document","title":"DELETE DOCUMENT"},{"content":"<h1 id=\"use-cases\">Use-cases</h1><p>Appbase uses Elasticsearch in the backend, and provides all the search queries and filters supported by ES, on the data stored in Appbase. Every data that’s pushed into Appbase is automatically indexed on ElasticSearch.</p>","link":"#/v3.0/search/use-cases/#use-cases","title":"USE-CASES"},{"content":"<h2 id=\"use-cases-elasticsearch-introduction\">Elasticsearch Introduction</h2><p>ElasticSearch is powered by Lucene, a powerful open-source full-text search library, under the hood. More than just full-text queries, ES can be used for numeric range queries, geo spatial queries, aggregation/ordering/grouping search results etc. In addition, we can combine these queries (logical and/or) and search across multiple collections and properties. To learn more about Elasticsearch, checkout <a href=\"http://exploringelasticsearch.com/\">this very effective guide</a>.</p>","link":"#/v3.0/search/use-cases/#use-cases-elasticsearch-introduction","title":"ELASTICSEARCH INTRODUCTION"},{"content":"<h2 id=\"use-cases-data-mapping\">Data Mapping</h2><p>As in Appbase has the concepts of collections, Documents and Properties, Elasticsearch has Types, Documents, and Fields. Let’s see how Appbase data is indexed and how these concepts are mapped.</p><p>In a nutshell, All the <em>documents</em> of Appbase are stored as <em>documents</em> inside ES, where the <em>collection</em> of the document becomes its <em>type</em>. <em>Properties</em> of the document can be accessed and filtered as <em>fields</em> inside ES.</p><p>All the examples in this doc ES concepts (Type, Document and Field), as we will be making direct Elasticsearch DSL query, but the query is explained in context the of data in Appbase, so Appbase concepts (collection, document and Property) are used.</p>","link":"#/v3.0/search/use-cases/#use-cases-data-mapping","title":"DATA MAPPING"},{"content":"<h2 id=\"use-cases-request-and-response-format\">Request and Response Format</h2><p>Appbase provides two REST API endpoints for performing search.</p><p>The <strong>1.</strong> searches across multiple collections and has an additional field to specify this in the request body. Both endpoints are compatible with <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/1.x/query-dsl.html\">ElasticSearch Query DSL</a> and return results in the same format.</p><p><code>Roadmap Note</code>:\nWe will be adding a search endpoint at the <strong>document</strong> level that queries on the document and it’s references.</p>","link":"#/v3.0/search/use-cases/#use-cases-request-and-response-format","title":"REQUEST AND RESPONSE FORMAT"},{"content":"<h3 id=\"use-cases-request-and-response-format-request\">Request</h3><p>A typical request object defines:</p><p>Elasticsearch provides rich Query DSL (Domain Specific Language) based on JSON to define queries. Queries involving major usecases are covered in this documentation, but if you want to know more about DSL, goto <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html\">this link</a>.</p><p>This is a sample request <strong>query object</strong>, let’s call it <code>body.json</code>:</p><p>Do not worry about the <code>body</code> of this object for now, we will see how to define it for different use cases in this document.</p><p>The entire curl request would look like: </p><p><code>Note:</code>\nThe search endpoint here is not on a particular collection, it is on the app. The collections on which the search should apply are defined in the request body.</p>","link":"#/v3.0/search/use-cases/#use-cases-request-and-response-format-request","title":"Request"},{"content":"<h3 id=\"use-cases-request-and-response-format-response\">Response</h3><p>We provide an unaltered DSL Response from ES. A typical response includes:</p><p>Elasticseach sidenote:\nThe <em>score</em> of a result describes how close it matches the query.</p><p>Example:</p>","link":"#/v3.0/search/use-cases/#use-cases-request-and-response-format-response","title":"Response"},{"content":"<h2 id=\"use-cases-searching\">Searching</h2><p>We see one by one, what queries apply in which search use cases, how you can combine them, and harness the full power that Elasticsearch provides.</p><p>In each use case below, it is first described how the data is stored, and what kind of search we are trying to achieve on the data. Let’s start with basic use case.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching","title":"SEARCHING"},{"content":"<h3 id=\"use-cases-searching-simple-match-and-fulltext\">Simple <em>Match</em> and Fulltext</h3><p>This is the most basic use case we can think of, where you want to just find out documents which contain a certain <em>term</em>, either as a string or a number.</p><p>For example, <em>“give me all the..”</em></p><p>We can use the <em>term filter</em> or <em>term query</em> for such cases.</p><p>Elasticseach sidenote</p><p>A <strong>filter</strong> in Elasticsearch says Yes or No for a document. I.E. If the document should be present in the results, or not.\nA <strong>query</strong> also <em>scores</em> the document (counts the relevance with the desired search term - a heavy operation) and results come sorted according to their score.</p><p>Many filters and queries are similar and can be used interchangeably, but its preferred to use queries only for a full text search based on relevance.</p><p>They can be used together. I.E. Filters are applied first and then on those results, the query is performed calculating the score. They can also be wrapped inside each other.</p><p>Read more about them <a href=\"http://exploringelasticsearch.com/searching_data.html#sec-searching-filtering\">here</a>.</p><p>For all the users with first name as “Andrew”,</p><p> The <em>term</em> filter can also be used for other datatypes, for e.g:</p><p>Another useful query is a <em>match query</em>. It allows to define a string of terms and it will find the documents which contains any of these terms. The more matching terms a document contains, the higher its score and higher it will be in the sorted results.</p><p>The above search request would find tweets which contains terms “hello” or “world” or both. This behavior can be controlled with <code>operator</code>. Its value defaults to “or”, but we can set to “and” as well.</p><p>The above search request would find tweets which contains terms “hello” and “world”, both.</p><p>Elasticseach sidenote</p><p>The equivalent filter for a <em>match query</em> is the <em>terms filter</em>.\nRead more about them:\n -  <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-match-query.html\"><em>match query</em> documentation</a>\n -  <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-terms-filter.html\"><em>terms filter</em> documentation</a></p><p>For more fine tuned searches, like on the users with first name as “Andrew” and last name as “Garlic”, we have to combine queries/filters. We see that later in this document.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-simple-match-and-fulltext","title":"Simple Match and Fulltext"},{"content":"<h3 id=\"use-cases-searching-fulltext-fuzzy\">Fulltext: Fuzzy</h3><p>A fuzzy search matches with the documents who have the terms matching <em>nearly</em>  the search term.</p><p>This is very useful for Google-like searches, where there could be some typing mistakes, or the user is not sure what word exactly he is searching for.</p><p>The simplest way to do a <em>fuzzy query</em> is:</p><p>The above query would return tweets with the message as “hella” or “hallo” etc.</p><p>Elasticseach sidenote</p><p>There are number of <em>fuzzy</em> queries in Elasticsearch and a number of ways to control the <em>fuzziness</em> of the term. Plus, you can search on a single or more properties (fields). Take a look at these documentations:\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html\"><em>fuzzy</em> query</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-flt-query.html\"><em>fuzzy-like-this</em> query</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html\"><em>more-like-this</em> query</a></p>","link":"#/v3.0/search/use-cases/#use-cases-searching-fulltext-fuzzy","title":"Fulltext: Fuzzy"},{"content":"<h3 id=\"use-cases-searching-fulltext-autocompletewildcard\">Fulltext Autocomplete/wildcard</h3><p>When you want to search based on few characters (generally a use case in autocomplete search bar), you can use the wildcard search.</p><p>Here’s an example, you will get all the results which has “laur” anywhere in the text.</p><p>Elasticseach sidenote</p><p>You can use either <code>*</code> or <code>?</code> as wildcards. <code>?</code> stands for a single characters, and <code>*</code> stands for any character length. Checkout the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/1.4/query-dsl-wildcard-query.html\">Elasticsearch documentation</a> for more.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-fulltext-autocompletewildcard","title":"Fulltext Autocomplete/wildcard"},{"content":"<h3 id=\"use-cases-searching-fulltext-fuzzy-and-autocomplete\">Fulltext: Fuzzy and Autocomplete</h3><p>Using the <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-combining-queriesfilters\">bool query</a>, which is explained <a href=\"http://docs.appbase.io/#/v3.0/search/use-cases#use-cases-searching-combining-queriesfilters\">later in this document</a>, we can combine above two cases into a single query and improve our search results.</p><p>Example:</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-fulltext-fuzzy-and-autocomplete","title":"Fulltext: Fuzzy and Autocomplete"},{"content":"<h3 id=\"use-cases-searching-numeric-range\">Numeric-range</h3><p><em>“Give me all the…”</em></p><p>We can use the <em>range filter</em>.</p><p>Elasticseach sidenote</p><p>It can also perform greater/less <em>or equal </em> searches. See the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-range-filter.html\"><em>range</em> filter documentation</a> for more details.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-numeric-range","title":"Numeric-range"},{"content":"<h3 id=\"use-cases-searching-geo-spatial\">Geo spatial</h3><p>Elasticsearch requires you to store your the geographic location using longitude and latitude, stored as a nested JSON object. Lets say that we are storing restaurants, along with their location. The data of a restaurant would be:</p><p>As long as the location is stored as above inside a document, we can do tons of geo spatial queries with Elasticsearch.</p><p>We can use <em>geo distance</em> filter to find documents located within specific distance from a geo point.</p><p>Find restaurants located within 5km from the point 40, -70.</p><p>Elasticseach sidenote</p><p>You can define the distance in real world Units like km, miles etc. There many ways the shape (box, polygon etc) and the range of this distance can be customized. Check out these documents for more details:\n- <a href=\"http://www.elasticsearch.org/blog/geo-location-and-search/\">Elasticsearch Geo Location tutorial</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-distance-filter.html\"><em>geo-distance</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-distance-range-filter.html\"><em>geo-distance-range</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-bounding-box-filter.html\"><em>geo-bounding-box</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-polygon-filter.html\"><em>geo-polygon</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-shape-filter.html\"><em>geo-shape</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geohash-cell-filter.html\"><em>geohash-cell</em> filter</a></p>","link":"#/v3.0/search/use-cases/#use-cases-searching-geo-spatial","title":"Geo spatial"},{"content":"<h3 id=\"use-cases-searching-sorting\">Sorting</h3><p>Results are sorted according to their <em>score</em> by default. We can change this behavior by applying <em>sort</em> parameter in the request.</p><p>Earlier in the <em>numeric range</em> use case, we searched for products in price range $50 and $100. Let’s sort the results according to their price, and then name.</p><p>Elasticseach sidenote</p><p>You can specify the order of the sort (asc, desc), you can also sort on multi-valued fields. Geo Location based sort is possible too.\nTake a look at the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html\"><em>sort</em> documentation</a>.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-sorting","title":"Sorting"},{"content":"<h3 id=\"use-cases-searching-aggregation\">Aggregation</h3><p>There are types of aggregation supported in Elasticsearch.</p><p>There wide varieties of aggregations and criteria, based on string-terms, locations, dates, numbers, etc. Take a look at the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations.html\"><em>Aggregation API</em> documentation</a>.</p>","link":"#/v3.0/search/use-cases/#use-cases-searching-aggregation","title":"Aggregation"},{"content":"<h3 id=\"use-cases-searching-combining-queriesfilters\">Combining queries/filters</h3><p>Case 1) <em>“Give me all the products which..”</em></p><p>Case 2)  <em>“Give me all the products which..”</em></p><p>Case 4) Multiple properties, <em>“Give me all the users which..”</em></p><p>Let’s take a very complex case,</p><p>Case 3) <em>“Give me all the products which..”</em></p><p>Writing these terms into a programming language like Javascript:</p><p>For such a case, Elasticsearch provides <em>bool query</em> or <em>bool filter</em>. In a bool query/filter you define the the other kind of queries/filters which should or must be satisfied or, must not be satisfied.</p><p>A bool query/filter can have three kinds of clauses:</p><p>Lets write the request to search the mobile phones we described above.</p><p>Elasticseach sidenote</p><p>As you can see in the example here, we have using bool filters. This way you can combine any kind of queries and filters, you can also combine multiple usecases (like fuzzy and wildcard), and write complex search requests. To know more check out:\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html\"><em>bool</em> query documentation</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-filter.html\"><em>bool</em> filter documentation</a></p>","link":"#/v3.0/search/use-cases/#use-cases-searching-combining-queriesfilters","title":"Combining queries/filters"},{"content":"<h2 id=\"use-cases-next-steps\">Next steps</h2><p>This document may only be able to give you a headstart on Elasticsearch, and it is impossible to cover every use case and feature provided by Elasticsearch.</p><p>If you have confusions on any of the use cases covered here, see the additional notes and links provided beside them.</p><p>To understand the Elasticsearch from the basics to advanced level, the book <a href=\"http://exploringelasticsearch.com/\">“Exploring Elasticsearch” by Andrew Cholakian</a>, and <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/index.html\">Elasticsearch: The Definitive Guide</a> are definitely helpful.</p>","link":"#/v3.0/search/use-cases/#use-cases-next-steps","title":"NEXT STEPS"},{"content":"<h1 id=\"steps-to-getting-started-with-appbase\">Steps to getting started with Appbase</h1>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase","title":"STEPS TO GETTING STARTED WITH APPBASE"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-0-get-appbase\">Step 0: Get Appbase</h2><p>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/developer/\">Appbase Dashboard</a>, and create a new app.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-0-get-appbase","title":"STEP 0: GET APPBASE"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-1-add-the-appbase-js-library\">Step 1: Add the Appbase JS Library</h2><p>Add Appbase library to your codebase and set the app credentials as they appear here.</p><p>Note: You will want to change the parameters of the <code>Appbase.credentials()</code> method to your own app name, app secret combination, as seen in the <a href=\"http://appbase.io/developer\">Dashboard</a>.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-1-add-the-appbase-js-library","title":"STEP 1: ADD THE APPBASE JS LIBRARY"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-2-creating-vertices\">Step 2: Creating Vertices</h2><p>Now let’s create two Appbase vertices under two different namespaces “user” and “tweets”.</p><p>Namespaces are containers that do not hold actual data, but help with data logic separation. A “vertex” can only be created using a ns reference object.</p><p>As seen here, vertex takes a “String” as an identifier. <code>Appbase.uuid()</code> is a handy way for creating a unique String id.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-2-creating-vertices","title":"STEP 2: CREATING VERTICES"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-3-storing-some-data\">Step 3: Storing some Data</h2><p>A vertex can store data as a JSON object using the <code>setData()</code> method.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-3-storing-some-data","title":"STEP 3: STORING SOME DATA"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-4-creating-a-simple-data-model\">Step 4: Creating a simple data model</h2><p>Vertices can be connected via edges. Now let’s add the <code>tweetRef</code> as an edge to the <code>userRef</code> vertex.</p><p>Now, the tweetRef vertex can also be accessed using the path /user/andy/tweeted. To retrieve a vertex reference at a given path, <code>ns.v(path)</code> is a handy method.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-4-creating-a-simple-data-model","title":"STEP 4: CREATING A SIMPLE DATA MODEL"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-5-retrieving-data-in-real-time\">Step 5: Retrieving data, in real-time!</h2><p>Appbase supports retrieval of objects using realtime streams. We will now add listeners, which return existing data stored, and keeps returning new data as it keeps changing. Similarly we will add a listener for retrieving edges on the vertex.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-5-retrieving-data-in-real-time","title":"STEP 5: RETRIEVING DATA, IN REAL-TIME!"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-step-6-smart-search\">Step 6: Smart search</h2><p>Appbase supports a full-text smart search, and you can enable it in two simple steps.</p><p>Enable the search by toggling the <i class=\"fa fa-eye-slash\"></i> switch in your app’s preferred namespace. If search is enabled, you should see this icon <i class=\"fa fa-eye\"></i> next to the namespace.\nSecond and final step, use this code snippet on the enabled namespace and have a full-text search widget.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-step-6-smart-search","title":"STEP 6: SMART SEARCH"},{"content":"<h2 id=\"steps-to-getting-started-with-appbase-further\">Further</h2><p>If you are using Appbase from a Javascript client, you might want to use user authentications over secret. Checkout <a href=\"/docs/authentications.html\">here</a> for more.</p><p>As a next step, you should checkout the <a href=\"/docs/js.html\">Javascript API reference</a> for an in-depth usage guide.</p>","link":"#/v2.0/javascript/quick-start/#steps-to-getting-started-with-appbase-further","title":"FURTHER"},{"content":"<h1 id=\"searching-for-a-better-search\">Searching for a better Search?</h1><p>Building a good quality full-text search experience for an app is a hard problem if your data resides in traditional RDBMS systems. Even database systems like MongoDB have very nascent support for search, others like DynamoDB offer no support. The hard, real fact is that these systems are not designed with search as a use-case, and one is left with a very rudimentary support like exact search match, or in the worst case scenario, even scanning the DB tables.</p><p>While there are great tools available for search, like Apache Solr and Elasticsearch, they have two big problems:<br>1. It is not recommended to use ElasticSearch as a primary data store. So you are still stuck with the problem of streaming data from your primary store to a search database like ES.<br>2. The documentation is intimidating. Really, it seems the docs are made for rocket scientists rather than your average app developer!</p><p>We have thought about the <strong>Search</strong> problem really hard, and have come up with an elegant solution.</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search","title":"SEARCHING FOR A BETTER SEARCH?"},{"content":"<h2 id=\"searching-for-a-better-search-our-approach-to-search\">Our Approach to Search</h2><p>Appbase takes the search problem head-on and indexes all the data that is ever stored in Appbase, allowing searching on all the data and relationships. We provide the ability to do the following kind of queries:<br>1. Full-text search - including <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-simple-match\">simple match queries</a> and <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-fuzzy\">fuzzy search queries</a>,<br>2. <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-numeric-range\">Numeric-range queries</a> - when you want answers to “Give me all the products that cost between $50 and $100” or “fetch all pages from 5 to 10”,<br>3. <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-geo-spatial\">Geo spatial queries</a> - ElasticSearch offers a lot of Geo Spatial queries. To name a few, you can compare distances, get a bounding box, determine shape,<br>4. <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-sorting\">Sort queries</a> - sort queries are more like filters to arrange data returned by one of above queries. You can sort the data using multiple “property” parameters.</p><p>With <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-aggregation\">Aggregation</a> and <a href=\"http://docs.appbase.io/docs/elasticsearch.html#-searching-combining-queries-filters\">Combining queries</a>, the possibilities are endless.</p><p>Here’s a primer to leverage these powerful search queries broken into three steps.</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search","title":"OUR APPROACH TO SEARCH"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-1-create-an-app\">1. Create an App</h3><p>Log into <span class=\"fa fa-external-link\"></span><a href=\"https://appbase.io/developer/\">Appbase Dashboard</a>, and create a new app. Once you create an app with a desired name, you should see an app dialog box appear as below.</p><p><img src=\"http://i.imgur.com/LBjXQQT.png\" alt=\"App credentials\"><br><strong>Image 1</strong>: App name, credentials, and access controls  </p><p>We will need the <code>app name</code> and the <code>secret</code> in all our API calls. In this case, these would be <em>my_app9</em> and <em>097b2b28b6a13cf2e53b6cecfec42b86</em>. We <strong>trust you</strong> with our app’s secret!</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-1-create-an-app","title":"1. Create an App"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-2-put-some-data\">2. Put some Data</h3><p>Appbase works with JSON data. You can store JSON objects with Appbase directly, they would form Appbase vertices (similar to MongoDB documents, or RDBMS records). We can make search requests on all the vertices, or a set of vertices via a JSON based query format (using ElasticSearch’s DSL).</p><p>For brevity, let’s suppose we are storing user profiles and would like to later search them by different properties. Here’s how a JSON user object might look: </p><p>To store this data with Appbase, we will make a <em>PATCH</em> request via REST. You can read more about them in our <a href=\"http://docs.appbase.io/docs/rest.html#api-reference-vertex-property-create-update-vertex-properties\">REST API</a>. Here’s how the request would like in our case:</p><p>When you copy the above code, be sure to replace the <code>Appbase-Secret</code> header and the <code>app name</code> in the URL to your credentials.</p><p><em>Understanding the Request</em></p><p>To store data, we do a <strong>PATCH</strong> request.</p><p>URL: <a href=\"https://api.appbase.io/my_app9/v2/people/laura/~properties\">https://api.appbase.io/my_app9/v2/people/laura/~properties</a>, where</p><p>Headers\nHeaders in this request include the <code>Appbase-Secret</code> value and <code>Content-Type</code> as JSON.</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-2-put-some-data","title":"2. Put some Data"},{"content":"<h3 id=\"searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data\">3. Perform Search on Data</h3><p>Now that we have successfully stored data, let’s perform a full-text search.</p><p>Before that, just a small setup in the dashboard to enable search. </p><p><img src=\"http://i.imgur.com/LBjXQQT.png\" alt=\"Select &quot;Data Browser&quot; View\"><br><strong>Image 2</strong>: Select the “Data Browser” view (3rd option).</p><p><img src=\"http://i.imgur.com/dUBq2fw.png\" alt=\"Enable Search View\"><br><strong>Image 3</strong>: Ensure search is enabled on the “people” namespace.</p><p>Inside the databrowser view, enable <strong>Search</strong>. The eye icon should appear <span style=\"color:green;\">green</span>, once the search is enabled.</p><p>Now we are all set to perform a “search” query. Let’s search for users whose occupation is being a <em>designer</em>.</p><p>The response that you get from Appbase is an array of JSON objects which match the criteria.</p><p>Response: </p><p>There you go! Appbase’s search fetches results which are close to the search term, and you get the following object in response.</p><p><em>Understanding the Request</em> </p><p>To perform a search, we do a <strong>POST</strong> request.</p><p>URL: <a href=\"https://api.appbase.io/my_app9/v2/people/~search\">https://api.appbase.io/my_app9/v2/people/~search</a>, where</p><p>Request Headers\nHeaders are always the same for all REST API requests.</p><p>Request Body\nThe JSON query object that we send with this request:</p><p>That’s it! In less than 10 minutes, we were able to add production grade search in your app.</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search-our-approach-to-search-3-perform-search-on-data","title":"3. Perform Search on Data"},{"content":"<h2 id=\"searching-for-a-better-search-next-steps\">Next Steps</h2><p>Do you want to customize the ‘fuzziness’ of your search? Or perhaps apply multiple queries and filter the data at the same time. If this has whetted your appetite, check out our main “search” course on the <a href=\"http://docs.appbase.io/#/v2.0/search/use-cases\">ElasticSearch documentation</a>.</p>","link":"#/v2.0/search/quick-start/#searching-for-a-better-search-next-steps","title":"NEXT STEPS"},{"content":"<h1 id=\"user-authentication\">User Authentication</h1><p>Most applications need to know the identity of a user. Knowing a user’s identity allows an app to provide a customized experience. The process of proving a user’s identity is called <em>authentication</em>.</p><p>Appbase makes authentication easy with completely client-side code. It has built-in functionality for third-party providers such as Facebook, LinkedIn, GitHub, Dropbox, and Google.</p><p>When a user authenticates to an Appbase app, the information about the user is returned in callbacks on the client device. This allows you to customize your app’s user experience for that specific user. Appbase also issues a <strong>requestObject</strong>, which makes it easy for you to access the providers’ data APIs.</p><p>Once a user authenticates to your app, Appbase manages their session, ensuring that the user is remembered across page refreshes and browser restarts.</p>","link":"#/v2.0/javascript/oauth/#user-authentication","title":"USER AUTHENTICATION"},{"content":"<h2 id=\"user-authentication-configuring-login\">Configuring Login</h2><p>For security reasons, only domains that you whitelist are allowed to initiate authentication for your app.  All Appbase apps have localhost and 127.0.0.1 enabled by default for local development and testing. Add more authorized origins to enable authentication from domains where your host your app.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-configuring-login","title":"CONFIGURING LOGIN"},{"content":"<h2 id=\"user-authentication-enabling-providers\">Enabling Providers</h2><p>Next, you need to enable the provider that you selected for your Appbase.</p><p>Appbase is all set up for your provider. It’s time to code.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-enabling-providers","title":"ENABLING PROVIDERS"},{"content":"<h2 id=\"user-authentication-logging-user-in\">Logging User In</h2><p>The following code shows a popup and retrieves the user’s credentials for Appbase, and Facebook.</p><p>Appbase automatically retrieves the basic information about the user (the <em>me</em> data) from the provider, the access tokens for Appbase and the provider and present it as the <em>authObj</em>.\n<code>authObj</code> is a JSON object:</p><p>Appbase stores and uses these tokens for accessing appbase REST api, and provider’s data APIs.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-logging-user-in","title":"LOGGING USER IN"},{"content":"<h2 id=\"user-authentication-accessing-providers-data-apis\">Accessing provider’s data APIs</h2><p><code>requestObj</code> returned in the authentication can be used to you to perform API calls to a provider. It contains methods that wrap the usual HTTP methods: <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, and <code>.del()</code>.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-accessing-providers-data-apis","title":"ACCESSING PROVIDER’S DATA APIS"},{"content":"<h2 id=\"user-authentication-caching-credentials\">Caching Credentials</h2><p>Once the user logs in with a provider, the credentials are cached in localStorage automatically, and this helps staying logged in across browser restarts. To fetch these cached credentails call, <code>Appbase.getAuth()</code>.</p><p><code>getAuth()</code> saves you from calling <code>authPopup()</code> again for authenticating user when the user already went through the login flow previously. It returns the two objects described object: <em>authObj</em> and <em>requestObj</em>. If user is not authenticated, it returns <code>null</code>.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-caching-credentials","title":"CACHING CREDENTIALS"},{"content":"<h2 id=\"user-authentication-dealing-with-popups-and-redirects\">Dealing with Popups and Redirects</h2><p>Appbase supports two different ways to authenticate with OAuth providers - via pop-up, or browser redirect.</p><p>Third-party authentication methods use a browser pop-up window, or browser redirect, to prompt the user to sign-in, approve the application, and return the user’s data to the requesting application.</p><p>Most modern browsers block pop-up windows unless they are invoked by direct user action. Therefore, we should only invoke the <code>authPopup()</code> method for third-party authentication upon the user’s click, otherwise <code>authRedirect()</code> should be used.</p><p><code>authRedirect()</code> redirects to the provider’s login page, where the user can accept your app’s permissions. Once he has, he is redirected to the callback url.</p><p>After this call, at the page where the redirect URL points, call <code>authCallback()</code>, which allows you to retrieve the credentials.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-dealing-with-popups-and-redirects","title":"DEALING WITH POPUPS AND REDIRECTS"},{"content":"<h2 id=\"user-authentication-working-with-scopes-and-additional-parameters\">Working with Scopes, and additional parameters</h2><p>Providers require different scope parameters, to access the user’s data on their APIs. \nFor eg. </p><p>Providers might even require additional parameters, which can be defined in the options to <code>Appbase.authPopup()</code> ,along with the <em>scope</em>:</p><p>Findout the different configurations, scopes and code samples for all the providers <a href=\"/docs/auth_providers-samples.md\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-working-with-scopes-and-additional-parameters","title":"WORKING WITH SCOPES, AND ADDITIONAL PARAMETERS"},{"content":"<h2 id=\"user-authentication-logging-users-out\">Logging Users Out</h2><p>This will remove the credentials from memory and all the requests to Appbase server and, and provider’s API will fail.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-logging-users-out","title":"LOGGING USERS OUT"},{"content":"<h2 id=\"user-authentication-code-samples\">Code Samples</h2><p>Findout code samples for all the providers <a href=\"/docs/auth_providers-samples.md\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#user-authentication-code-samples","title":"CODE SAMPLES"},{"content":"<h1 id=\"authentication-additional-guide\">Authentication - additional guide</h1><p>Every provider requires Oauth paramters to be passed while authenticating. Mostly, they are the same across all providers, for eg. redirect_url, token_type, client_id etc. Appbase takes care of these paramters, except for some cases, which depends on the developer’s need. This document explains how to provide these paramters while authenticating with Appbase and a provider, plus provides links to provider’s additional documentation.</p><p>You can directly use the code snippets given here for a provider, and the authentication will work out of the box.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide","title":"AUTHENTICATION - ADDITIONAL GUIDE"},{"content":"<h2 id=\"authentication-additional-guide-scopes\">Scopes</h2><p>Scoping allows OAuth clients to tell an authorization server what permissions they’ll need on resources they’re accessing. The required scopes, can be specified while calling <code>Appbase.authPopup()</code>, and then we can access the data using <code>requestObject</code>, and calling provider’s data endpoints.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-scopes","title":"SCOPES"},{"content":"<h2 id=\"authentication-additional-guide-google\">Google</h2>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-google","title":"GOOGLE"},{"content":"<h3 id=\"authentication-additional-guide-google-required-paramters\">Required paramters</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-google-required-paramters","title":"Required paramters"},{"content":"<h3 id=\"authentication-additional-guide-google-minimal-code\">Minimal Code</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-google-minimal-code","title":"Minimal Code"},{"content":"<h3 id=\"authentication-additional-guide-google-additional-docs\">Additional docs</h3><p>Find out more about scopes and API endpoints supported by Google <a href=\"https://developers.google.com/+/api/oauth#scopes\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-google-additional-docs","title":"Additional docs"},{"content":"<h3 id=\"authentication-additional-guide-google-calling-apis\">Calling APIs</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-google-calling-apis","title":"Calling APIs"},{"content":"<h2 id=\"authentication-additional-guide-facebook\">Facebook</h2>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-facebook","title":"FACEBOOK"},{"content":"<h3 id=\"authentication-additional-guide-facebook-minimal-code\">Minimal Code</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-facebook-minimal-code","title":"Minimal Code"},{"content":"<h3 id=\"authentication-additional-guide-facebook-additional-docs\">Additional docs</h3><p>Find out more about scopes and API endpoints supported by Facebook <a href=\"https://developers.facebook.com/docs/facebook-login/permissions/v2.1\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-facebook-additional-docs","title":"Additional docs"},{"content":"<h2 id=\"authentication-additional-guide-linkedin\">LinkedIn</h2>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin","title":"LINKEDIN"},{"content":"<h3 id=\"authentication-additional-guide-linkedin-minimal-code\">Minimal Code</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin-minimal-code","title":"Minimal Code"},{"content":"<h3 id=\"authentication-additional-guide-linkedin-additional-docs\">Additional docs</h3><p>Find out more about scopes and API endpoints supported by LinkedIn <a href=\"https://developer.linkedin.com/documents/authentication#granting\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-linkedin-additional-docs","title":"Additional docs"},{"content":"<h2 id=\"authentication-additional-guide-github\">Github</h2>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-github","title":"GITHUB"},{"content":"<h3 id=\"authentication-additional-guide-github-minimal-code\">Minimal Code</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-github-minimal-code","title":"Minimal Code"},{"content":"<h3 id=\"authentication-additional-guide-github-additional-docs\">Additional docs</h3><p>Find out more about scopes and API endpoints supported by Github <a href=\"https://developer.github.com/v3/oauth/#scopes\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-github-additional-docs","title":"Additional docs"},{"content":"<h2 id=\"authentication-additional-guide-dropbox\">Dropbox</h2>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox","title":"DROPBOX"},{"content":"<h3 id=\"authentication-additional-guide-dropbox-minimal-code\">Minimal Code</h3>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox-minimal-code","title":"Minimal Code"},{"content":"<h3 id=\"authentication-additional-guide-dropbox-additional-docs\">Additional docs</h3><p>Find out more about API endpoints supported by Dropbox <a href=\"https://www.dropbox.com/developers/core/docs#account-info\">here</a>.</p>","link":"#/v2.0/javascript/oauth/#authentication-additional-guide-dropbox-additional-docs","title":"Additional docs"},{"content":"<h1 id=\"datamodel\">Datamodel</h1><p>Appbase is a realtime Database as a Service (DBaaS), built on top of a graph schema with JSON based vertices (similar to JSON documents), and edges to link them.</p><p>All databases support the storing and fetching of data, what distinguishes one database type from another is the structure of the data they store and the means by which it can be retrieved. </p><p>Several popular databases can be classified as below:</p>","link":"#/v2.0/concepts/datamodel/#datamodel","title":"DATAMODEL"},{"content":"<h2 id=\"datamodel-data-in-appbase\">Data in Appbase</h2><p>Appbase is a <a href=\"http://en.wikipedia.org/wiki/Directed_graph\"><em>Directed Graph</em></a>. Objects inside Appbase are called <a href=\"http://en.wikipedia.org/wiki/Vertex_(graph_theory\">Vertices</a>) (a graph term for entities), and the links (relationships) between the objects are called <a href=\"http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Basics\">Edges</a>.</p><p>Data in Appbase is stored as JSON objects. Appbase supports flexible schema, i.e. the properties of the JSON object need not be defined in advance. </p><p>Although Appbase supports storing embedded JSON objects and arrays, one doesn’t have to store data in this denormalized fashion. This is mainly for compatibility with existing document stores like MongoDB. The recommended approach is to create reference links between distint entities. In this doc, we will cover how you can store different kinds data (primitive values, objects, lists), create relationships amongst them, normalize, and do perform different queries on them.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-data-in-appbase","title":"DATA IN APPBASE"},{"content":"<h2 id=\"datamodel-concepts\">Concepts</h2><p>Similar to how SQL has concepts for <em>table</em>, <em>row</em>, <em>column</em>, <em>relation</em> and MongoDB has <em>collection</em> , <em>Document</em> and <em>fields</em>, here are the key concepts in Appbase.</p><p><strong>Vertex</strong> — is similar to a <em>Document</em> in MongoDB, it stores data.  </p><p><strong>Namespace</strong> — is similar to a <em>Collection</em> in MongoDB or <em>type</em> in ElasticSearch. A <em>vertex</em> always belongs to a <em>namespace</em> and <em>security rules</em> can be applied on <em>namespaces</em>. </p><p><strong>Edge</strong> — is a directional link to another vertex.  </p><p>i.e. an <em>edge</em> is pointed from <em>inVertex</em> to an <em>outVertex</em>.</p><p><strong>Path</strong> — Every <em>vertex</em> in Appbase has a path, starting from the &lt;namespace&gt; and ending at the <em>vertex</em>, not unlike the UNIX path. A typical path looks like &lt;namespace&gt;/&lt;v1&gt;/&lt;v2&gt;/…/&lt;vn&gt;/.</p><p><strong>URL</strong> — It is a way to point to a <em>Path</em> in the REST API. Paths are prefixed with the Appbase API base URL, application’s name and the API version. Eg. <a href=\"https://api.appbase.io/chat_app/v2/&lt;path&gt;/\">https://api.appbase.io/chat_app/v2/&lt;path&gt;/</a>.</p><p>We can not actually compare these concepts with other kinds of databases, but it helps to understand Appbase if we compare the <em>usage practices</em>.</p><p>With this table in mind, lets understand how the concepts work.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts","title":"CONCEPTS"},{"content":"<h3 id=\"datamodel-concepts-vertex\">Vertex</h3><p>Vertex is the the standard data container in Appbase. A vertex can store a valid JSON object and be linked to other vertices via <em>edges</em>.</p><p>It can also store nested JSON objects and arrays, but this is only for convenience. In practice, vertices act as singular data entities, i.e. you store only the data relevant to a single entity in the real world. For e.g. a person’s age, name, height, sex can be stored in a single vertex, but the data of his belongings, like a book or a car is a completely different entity. This new entity will have properties of its own and they should be stored inside a new vertex. Later in this document, we will see how we can create a relation between these two entities.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts-vertex","title":"Vertex"},{"content":"<h3 id=\"datamodel-concepts-namespace\">Namespace</h3><p>Namespaces are a way to combine <em>similar</em> entities. For eg. all vertices storing different users can be stored inside the <em>user</em> namespace and all the tweets (repreented as vertices) can be stored inside the <em>tweet</em> namespace. Since namespace is a logical container, different kinds of objects can be stored inside a single namespace. This allows searching for <em>similar vertices</em> and applying <em>security rules</em> with ease.</p><p>Namespaces are <em>searchable</em>. We are using the open-source <a href=\"http://www.elasticsearch.org/\">ElasticSearch</a> behind the scenes to support this use-case. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for a quick intro on how search works.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts-namespace","title":"Namespace"},{"content":"<h3 id=\"datamodel-concepts-edge-one-to-one-relationships\">Edge (one-to-one relationships)</h3><p>After creating entities, its time to create relations amongst them via <em>edges</em>. </p><p>An edge is a <em>named</em> directional link connecting two vertices for a purpose, a <em>one-to-one relation</em>. For instance, a book has an author, a husband has wife and a child has a mother. The edges for these would be <em>book vertex</em> <code>--authouredBy-&gt;</code> <em>person vertex</em>, <em>man vertex</em> <code>--marriedTo-&gt;</code> <em>woman vertex</em>. </p><p>Edges are directional, so if you set the edge <em>man</em> <code>--marriedTo-&gt;</code> <em>woman</em>, it only tells us that the man is married to the woman, but it tells us nothing about woman’s relationship status. For that, another edge, <em>woman</em> <code>--marriedTo-&gt;</code> <em>man</em>, should be created.</p><p>Appbase only allows for unique edge names. The default behaviour is last-write-wins in case a new edge is created with an existing name. Edges have priorities which are rational numbers (think of the <code>Number</code> datatype in Javascript).</p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts-edge-one-to-one-relationships","title":"Edge (one-to-one relationships)"},{"content":"<h3 id=\"datamodel-concepts-path\">Path</h3><p>Paths are the way to interact with vertices in Appbase. Paths are constructed with &lt;namespace&gt;/&lt;vertexKey&gt;/&lt;edgeName_1&gt;/…/&lt;edgeName_N&gt;/.</p><p>Creating edges create deeper <em>Paths</em>. Lets take the example of the movie Inception, the Oscar deserver lead actor Leonardo DiCaprio, and the director Christopher Nolan. Here are the vertices stored in Appbase:</p><p>These vertices can be accessed with the following paths, as entry points in the graph:</p><p>Let’s create edges:</p><p><img src=\"http://i.imgur.com/2Asfr9r.png\" alt=\"\"></p><p>With these edge, we created these deeper paths:</p><p><code>movie/inception/leadActor</code> : points to the same vertex as <code>person/dicaprio</code></p><p><code>movie/inception/directedBy</code> : points to <code>person/nolan</code></p><p><code>person/nolan/marriedTo</code>: points to <code>person/emma</code></p><p>Here’s the <em>magic</em>, the path <code>movie/inception/directedBy/marriedTo</code> points directly to <code>person/emma</code></p><p>This means, modifying the data stored at <code>movie/inception/directedBy/marriedTo</code> will change the data of <code>person/emma</code> as they both are the same vertices.</p><p>Paths are powerful ways to point to the exact data you want to interact with. For e.g.  when you access the path <code>movie/inception/directedBy/marriedTo</code>, you are only interested in the vertex representing the person who is married to the director of Inception, and nothing else. You never access the data of the movie Inception, or the director.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts-path","title":"Path"},{"content":"<h3 id=\"datamodel-concepts-url\">URL</h3><p>A URL is just another representation of a <em>Path</em>. REST API URL looks like this: <a href=\"https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/\">https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/</a>. </p><p>Assuming the Application’s name as <em>imdb</em>, URL for the path <em>movie/inception/directedBy/marriedTo</em> would be <code>https://api.appbase.io/imdb/v2/movie/inception/directedBy/marriedTo</code></p>","link":"#/v2.0/concepts/datamodel/#datamodel-concepts-url","title":"URL"},{"content":"<h2 id=\"datamodel-storing-data\">Storing Data</h2><p>Being a Graph, Appbase allows you to create any kind of data structures you want, you just need to know exactly how. Lets see how to store the practical data structures we used on daily basis.</p><p>The examples here use Appbase Javascript Library and if any of the method is confusing you, feel free to chekout the <a href=\"http://docs.appbase.io/#/v2.0/javascript/api-reference\">JS Documentation</a>.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-storing-data","title":"STORING DATA"},{"content":"<h3 id=\"datamodel-storing-data-primitive-data-and-json-objects\">Primitive Data and JSON Objects</h3><p>Numbers, Characters, Strings and Booleans, are stored as values of the properties inside a vertex. Dates can be converted into the milliseconds since epoch, and store them as Numbers. For eg. you want to store a the movie’s name, and its release year, you can store combine all of them as a JSON object and store it inside a vertex.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-storing-data-primitive-data-and-json-objects","title":"Primitive Data and JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-nested-json-objects\">Nested JSON Objects</h3><p>You can store nested objects directly inside a vertex. E.g.</p><p>This would work perfectly. Notice that you are not storing the director (Nolan) of Inception as a <em>different entity</em>, instead as a <em>property</em> of the movie itself. While this approach is sometimes handy, it limits you in terms of what you can do with Nolan. I.e. you will not be able to establish any direct relationships with Nolan, as it is not an entity in itself. For eg. Nolan is married to Emma, but there is no way to create a link between Nolan  and Emma, when it is stored as a nested object in Appbase.</p><p>A better to do this is store Nolan as a new vertex, and create an edge from Inception to Nolan. You can create another vertex for Emma create edges with Nolan. </p><p>We will create three edges here: </p><p>inception <code>--directedBy-&gt;</code> nolan</p><p>nolan <code>--marriedTo-&gt;</code> emma\nRecall that the edges are <em>directional</em>, so this 2nd edge only tells us that Nolan in married to Emma, but says nothing about Emma’s marital status. That’s why we create the third edge: </p><p>emma <code>--marriedTo-&gt;</code> nolan</p><p><img src=\"http://i.imgur.com/IipHJzL.png\" alt=\"\"></p><p>Notice that Inception directed by Nolan, is a One-to-One relationship. Nolan has directed many movies, and that’s a case of One-to-Many relationships. We see later how to create them in Appbase. </p>","link":"#/v2.0/concepts/datamodel/#datamodel-storing-data-nested-json-objects","title":"Nested JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-sets-one-to-many-relationship\">Sets (One-to-Many Relationship)</h3><p>A set makes sure that all the items in the list exist only once. Consider this example, the movies directed by Nolan. We will make only a small list here:  <code>[\"Interstellar\", \"Inception\", \"The Dark Night\", \"Memento\"]</code>. Clearly, it doesn’t make sense to have any of the movies twice in the this list.  Notice that this is a One-to-Many relationship here. <em>Nolan</em> (1) -&gt; <em>Movies</em> (N).</p><p>Operations on a single set are: addition, checking existence of an item, deletion and traversal. </p><p>Operations on multiple sets, like union and intersection can be emulated using single-set operations. For e.g.</p><p>Let’s see a practical set, the movies directed by Nolan. </p><p>In Appbase, the Set is a vertex, let’s create it.</p><p>Also the Items in the set are vertices.</p><p>Now we have Appbase Vertex References to the Set and the Items, lets go through different set operations.</p><p>Simply creating an edge from the Set to the Item. We will use the Primary Key (<code>inceptionRef.name()</code>) of the item as the name of the edge.</p><p>Here, the important thing is to keep the edge-name exactly as the Vertex Key. That way makes sure that every item will exist only once in the set. For e.g. if you try to add <code>inceptionRef</code> again in the set, it will just replace the old edge no extra edges will be created.</p><p>Keeping the edge-name same as the Vertex Key of the item, allows other operations as well, like deletion of an Item and checking where an Item exists.</p><p>Remove the edge from Set to the Item.</p><p>As we kept the edge name exactly as the Vertex Key, it means that we can use the Vertex Key to delete the edge as well.</p><p>It’s not possible to check via the Item’s data, if the item exists or not. The only way we can check, is using the Vertex Key/edge-name. We see that if there’s an edge, with its name as the Vertex Key. We use <code>outVertex()</code> and <code>isValid()</code> for that. I.e. we are checking if the path <code>set/moviesByNolan/&lt;movieVertexKey&gt;</code> is valid or not.</p><p>As all the items are the edges of the Set vertex, we simply fetch the edges of the Set vertex, and traverse through them.</p><p>See <em>Retrieving Data</em> section.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-storing-data-sets-one-to-many-relationship","title":"Sets (One-to-Many Relationship)"},{"content":"<h2 id=\"datamodel-retrieving-data\">Retrieving Data</h2><p>In a nutshell, Namspaces in Appbase have vertices, and vertices have properties, edges.</p><p>Data retrieval in Appbase happens via <em>realtime streams</em>. These streams allows you to fetch existing data, and then keep listening to new data as well.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-retrieving-data","title":"RETRIEVING DATA"},{"content":"<h3 id=\"datamodel-retrieving-data-properties\">Properties</h3><p>When you start listening to the properties of a vertex, you first get the existing properties, and then as the data keeps changing, the callback is called again with new properties.</p><p>Appbase gives you the properties data as a <em>snapshot</em>. The snapshots are immutable copies of the data stored in a vertex. Any changes you make in the snapshot will not be stored in Appbase. </p><p>If you don’t want to listen to the properties any more, you can turn the listener off with <code>inceptionRef.off()</code>.</p><p>For convenience, we have the method  <code>inceptionRef.once()</code> when you want to listen to daat just only once.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-retrieving-data-properties","title":"Properties"},{"content":"<h3 id=\"datamodel-retrieving-data-edges\">Edges</h3><p>Retrieving existing edges of a vertex is simple: just listen to <em>edge_added</em> event, which will return existing edges at first. When new edges are added, the callback will be fired for new edges as well.</p><p>Notice that the if there are ‘N’ number of existing edges, the callback will be called ‘N’ times.</p><p><code>eRef</code> here is the Appbase Reference to the outVertex, and <code>eSnap</code> is the snapshot of the edge. Edge Snapshot is the snapshot of the data stored with the edge and the out vertex, mainly the <em>priority</em> of the edge, and the properties of the out vertex. <code>eSnap.priority()</code> will give you the priority, and <code>eSnap.properties()</code> will give you properties.</p><p>With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them, or want to fetch only a particular edge.</p><p>When more than one filter is provided, they work as logical <code>AND</code> and only the edges matchihg all filters will be fetched. This is what each filter means:</p><p>Notice that:\n - Filters are a way to fetch existing edges, thus they work only with <em>edge_added</em> event\n - Edges are always returned ordered according to their priorities\n - When <em>endAt</em> &lt; <em>startAt</em>, edges are returned in reverse order\n - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime\n    - This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code>\n    - <em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</p>","link":"#/v2.0/concepts/datamodel/#datamodel-retrieving-data-edges","title":"Edges"},{"content":"<h3 id=\"datamodel-retrieving-data-vertices-in-a-namespace\">Vertices in a Namespace</h3><p>Namespaces are vertex containers, and it is possible to retrieve existing vertices, and listen to updates when new vertices are added or old vertices are removed.</p><p>The callback attached with <em>vertex_added</em> event is called for all the existing vertices. As new vertices are added, it is called for them too.</p><p>To listen to updates of vertex removal, use <em>vertex_removed</em> event.</p><p>With ElasticSearch’s powerful APIs in the backend, Appbase supports full-text fuzzy search queries on the data stored into vertices of a namespace. A sample query on a namespace looks something like this: </p><p>This query searches on all the vertices of the namespace <em>movie</em>, and returns an array of vertices who’s property <code>year</code>, matches fuzzily with the text “2010”. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for more details.</p>","link":"#/v2.0/concepts/datamodel/#datamodel-retrieving-data-vertices-in-a-namespace","title":"Vertices in a Namespace"},{"content":"<h1 id=\"use-cases\">Use-cases</h1><p>Appbase uses opensource Elasticsearch in the backend, and provides all the powerful search features of ES, on the data stored in Appbase.</p><p>When you want to make some data <em>searchable</em>, you have to enable search on a namespace in the <em>Dashboard</em>. In the <em>Data Browser</em>, enable the search by toggling the <i class=\"fa fa-eye-slash\"></i> switch on the namespace. If search is enabled, you should see this icon <i class=\"fa fa-eye\"></i> next to the namespace. </p><p>Enabling search on a namespace causes all the vertices inside the namespace to be indexed inside Elasticsearch. New vertices created inside this namespace are automatically indexed, and searchable. When the data of a vertex is updated, the indices update automatically and new data is searchable.</p>","link":"#/v2.0/search/use-cases/#use-cases","title":"USE-CASES"},{"content":"<h2 id=\"use-cases-elasticsearch-introduction\">Elasticsearch Introduction</h2><p>ElasticSearch is powered by Lucene, a powerful open-source full-text search library, under the hood. More than just full-text queries, ES can be used for numeric range queries, geo spatial queries, aggregation/ordering/grouping search results etc. In addition, we can combine these queries (logical and/or) and search across multiple namespaces and properties. To learn more about Elasticsearch, checkout <a href=\"http://exploringelasticsearch.com/\">this very effective guide</a>.</p>","link":"#/v2.0/search/use-cases/#use-cases-elasticsearch-introduction","title":"ELASTICSEARCH INTRODUCTION"},{"content":"<h2 id=\"use-cases-data-mapping\">Data Mapping</h2><p>As in Appbase has the concepts of Namespaces, Vertices and Properties, Elasticsearch has Types, Documents, and Fields. Let’s see how Appbase data is indexed and how these concepts are mapped.</p><p>In a nutshell, All the <em>vertices</em> of Appbase are stored as <em>documents</em> inside ES, where the <em>namespace</em> of the vertex becomes its <em>type</em>. <em>Properties</em> of the vertex can be accessed and filtered as <em>fields</em> inside ES. </p><p>All the examples in this doc ES concepts (Type, Document and Field), as we will be making direct Elasticsearch DSL query, but the query is explained in context the of data in Appbase, so Appbase concepts (Namespace, Vertex and Property) are used.</p>","link":"#/v2.0/search/use-cases/#use-cases-data-mapping","title":"DATA MAPPING"},{"content":"<h2 id=\"use-cases-request-and-response-format\">Request and Response Format</h2><p>To do a raw ES query on the data, Appbase provides a <a href=\"\">REST API endpoint</a> and the Javascript library method <a href=\"\"><code>Appbase.rawSearch()</code></a>. Both of them, accepts similar request Query Object, and gives similar responses. </p>","link":"#/v2.0/search/use-cases/#use-cases-request-and-response-format","title":"REQUEST AND RESPONSE FORMAT"},{"content":"<h3 id=\"use-cases-request-and-response-format-request\">Request</h3><p>A typical request object defines:</p><p>Elasticsearch provides rich Query DSL (Domain Specific Language) based on JSON to define queries. Queries involving major usecases are covered in this documentation, but if you want to know more about DSL, goto <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html\">this link</a>.</p><p>This is a sample request Query Object: </p><p>Do not worry about the <code>body</code> of this object for now, we will see how to define it for different use cases in this document.</p>","link":"#/v2.0/search/use-cases/#use-cases-request-and-response-format-request","title":"Request"},{"content":"<h3 id=\"use-cases-request-and-response-format-response\">Response</h3><p>We provide an unaltered DSL Response from ES. A typical response includes:</p><p><sup>Elasticseach sidenote</sup>\nThe <em>score</em> of a result describes how close it matches the query.</p><p>Example: </p>","link":"#/v2.0/search/use-cases/#use-cases-request-and-response-format-response","title":"Response"},{"content":"<h2 id=\"use-cases-searching\">Searching</h2><p>We see one by one, what queries apply in which search use cases, how you can combine them, and harness the full power that Elasticsearch provides. </p><p>In each use case below, it is first described how the data is stored, and what kind of search we are trying to achieve on the data. Let’s start with basic use case.</p>","link":"#/v2.0/search/use-cases/#use-cases-searching","title":"SEARCHING"},{"content":"<h3 id=\"use-cases-searching-simple-match\">Simple <em>Match</em></h3><p>This is the most basic use case we can think of, where you want to just find out vertices which contain a certain <em>term</em>, either as a string or a number. </p><p>For example, <em>“give me all the..”</em></p><p>We can use the <em>term filter</em> or <em>term query</em> for such cases.</p><p><sup>Elasticseach sidenote</sup></p><p>A <strong>filter</strong> in Elasticsearch says Yes or No for a document. I.E. If the document should be present in the results, or not. \nA <strong>query</strong> also <em>scores</em> the document (counts the relevance with the desired search term - a heavy operation) and results come sorted according to their score.</p><p>Many filters and queries are similar and can be used interchangeably, but its preferred to use queries only for a full text search based on relevance.</p><p>They can be used together. I.E. Filters are applied first and then on those results, the query is performed calculating the score. They can also be wrapped inside each other. </p><p>Read more about them <a href=\"http://exploringelasticsearch.com/searching_data.html#sec-searching-filtering\">here</a>.</p><p>For all the users with first name as “Andrew”,</p><p> The <em>term</em> filter can also be used for other datatypes, for e.g:</p><p>Another useful query is a <em>match query</em>. It allows to define a string of terms and it will find the documents which contains any of these terms. The more matching terms a vertex contains, the higher its score and higher it will be in the sorted results.</p><p>The above search request would find tweets which contains terms “hello” or “world” or both. This behavior can be controlled with <code>operator</code>. Its value defaults to “or”, but we can set to “and” as well. </p><p>The above search request would find tweets which contains terms “hello” and “world”, both.</p><p><sup>Elasticseach sidenote</sup></p><p>The equivalent filter for a <em>match query</em> is the <em>terms filter</em>.\nRead more about them: \n -  <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-match-query.html\"><em>match query</em> documentation</a>\n -  <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-terms-filter.html\"><em>terms filter</em> documentation</a></p><p>The <em>multi_match</em> query can search on multiple fields (properties) and returned if <em>any</em> of those properties match <em>any</em> of the terms.</p><p>The below query would search for users with either first name or last name, being “Andrew” or “Garlic”. I.E. also the users with first name as “Garlic” would be included, and vice versa.</p><p>For more fine tuned searches, like on the users with first name as “Andrew” and last name as “Garlic”, we have to combine queries/filters. We see that later in this document.</p>","link":"#/v2.0/search/use-cases/#use-cases-searching-simple-match","title":"Simple Match"},{"content":"<h3 id=\"use-cases-searching-fuzzy\">Fuzzy</h3><p>A fuzzy search matches with the documents who have the terms matching <em>nearly</em>  the search term.</p><p>This is very useful for Google-like searches, where there could be some typing mistakes, or the user is not sure what word exactly he is searching for. </p><p>The simplest way to do a <em>fuzzy query</em> is:</p><p>The above query would return tweets with the message as “hella” or “hallo” etc. </p><p><sup>Elasticseach sidenote</sup></p><p>There are number of <em>fuzzy</em> queries in Elasticsearch and a number of ways to control the <em>fuzziness</em> of the term. Plus, you can search on a single or more properties (fields). Take a look at these documentations:\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html\"><em>fuzzy</em> query</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-flt-query.html\"><em>fuzzy-like-this</em> query</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html\"><em>more-like-this</em> query</a></p>","link":"#/v2.0/search/use-cases/#use-cases-searching-fuzzy","title":"Fuzzy"},{"content":"<h3 id=\"use-cases-searching-numeric-range\">Numeric-range</h3><p><em>“Give me all the…”</em></p><p>We can use the <em>range filter</em>.</p><p><sup>Elasticseach sidenote</sup></p><p>It can also perform greater/less <em>or equal </em> searches. See the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-range-filter.html\"><em>range</em> filter documentation</a> for more details.</p>","link":"#/v2.0/search/use-cases/#use-cases-searching-numeric-range","title":"Numeric-range"},{"content":"<h3 id=\"use-cases-searching-geo-spatial\">Geo spatial</h3><p>Elasticsearch requires you to store your the geographic location using longitude and latitude, stored as a nested JSON object. Lets say that we are storing restaurants, along with their location. The data of a restaurant would be: </p><p>As long as the location is stored as above inside a vertex, we can do tons of geo spatial queries with Elasticsearch.</p><p>We can use <em>geo distance</em> filter to find vertices located within specific distance from a geo point.</p><p>Find restaurants located within 5km from the point 40, -70.</p><p><sup>Elasticseach sidenote</sup></p><p>You can define the distance in real world Units like km, miles etc. There many ways the shape (box, polygon etc) and the range of this distance can be customized. Check out these documents for more details: \n- <a href=\"http://www.elasticsearch.org/blog/geo-location-and-search/\">Elasticsearch Geo Location tutorial</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-distance-filter.html\"><em>geo-distance</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-distance-range-filter.html\"><em>geo-distance-range</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-bounding-box-filter.html\"><em>geo-bounding-box</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-polygon-filter.html\"><em>geo-polygon</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geo-shape-filter.html\"><em>geo-shape</em> filter</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/query-dsl-geohash-cell-filter.html\"><em>geohash-cell</em> filter</a></p>","link":"#/v2.0/search/use-cases/#use-cases-searching-geo-spatial","title":"Geo spatial"},{"content":"<h3 id=\"use-cases-searching-sorting\">Sorting</h3><p>Results are sorted according to their <em>score</em> by default. We can change this behavior by applying <em>sort</em> parameter in the request.</p><p>Earlier in the <em>numeric range</em> use case, we searched for products in price range $50 and $100. Let’s sort the results according to their price, and then name.</p><p><sup>Elasticseach sidenote</sup></p><p>You can specify the order of the sort (asc, desc), you can also sort on multi-valued fields. Geo Location based sort is possible too.\nTake a look at the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-request-sort.html\"><em>sort</em> documentation</a>.</p>","link":"#/v2.0/search/use-cases/#use-cases-searching-sorting","title":"Sorting"},{"content":"<h3 id=\"use-cases-searching-aggregation\">Aggregation</h3><p>There are types of aggregation supported in Elasticsearch. </p><p>There wide varieties of aggregations and criteria, based on string-terms, locations, dates, numbers, etc. Take a look at the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations.html\"><em>Aggregation API</em> documentation</a>.</p>","link":"#/v2.0/search/use-cases/#use-cases-searching-aggregation","title":"Aggregation"},{"content":"<h3 id=\"use-cases-searching-combining-queriesfilters\">Combining queries/filters</h3><p><em>“Give me all the products which..”</em></p><p>Writing these terms into a programming language like Javascript: </p><p>For such a case, Elasticsearch provides <em>bool query</em> or <em>bool filter</em>. In a bool query/filter you define the the other kind of queries/filters which should or must be satisfied or, must not be satisfied.</p><p>A bool query/filter can have three kinds of clauses:</p><p>Lets write the request to search the mobile phones we described above.</p><p><sup>Elasticseach sidenote</sup></p><p>As you can see in the example here, we have using bool filters. This way you can write really complex search requests. To know more check out:\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html\"><em>bool</em> query documentation</a>\n- <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-filter.html\"><em>bool</em> filter documentation</a></p>","link":"#/v2.0/search/use-cases/#use-cases-searching-combining-queriesfilters","title":"Combining queries/filters"},{"content":"<h2 id=\"use-cases-next-steps\">Next steps</h2><p>This document may only be able to give you a headstart on Elasticsearch, and it is impossible to cover every use case and feature provided by Elasticsearch. </p><p>If you have confusions on any of the use cases covered here, see the additional notes and links provided beside them.</p><p>To understand the Elasticsearch from the basics to advanced level, the book <a href=\"http://exploringelasticsearch.com/\">“Exploring Elasticsearch” by Andrew Cholakian</a>, and <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/index.html\">Elasticsearch: The Definitive Guide</a> are definitely helpful.</p>","link":"#/v2.0/search/use-cases/#use-cases-next-steps","title":"NEXT STEPS"},{"content":"<h1 id=\"introduction\">Introduction</h1><p>The Appbase JS library allows developers to create realtime multi-user apps using a graph data model and realtime smart-search capabilities.</p><p>To use it in the browser, use this link: <a href=\"https://cdn.appbase.io/latest/appbase.js\">https://cdn.appbase.io/latest/appbase.js</a></p><p>To use it with nodejs, do <code>npm install appbasejs</code></p><p>The Appbase library exposes the <code>Appbase</code> object. The methods in the JS lib rely on three main objects.</p>","link":"#/v2.0/javascript/api-reference/#introduction","title":"INTRODUCTION"},{"content":"<h1 id=\"appbase\">Appbase</h1><p><strong>Appbase</strong> is the global object exposed the JS library. It has the following four methods: <code>credentials()</code>, \n<code>ns()</code>, <code>uuid()</code>, and <code>serverTime()</code>.</p>","link":"#/v2.0/javascript/api-reference/#appbase","title":"APPBASE"},{"content":"<h2 id=\"appbase-setting-up\">Setting up</h2>","link":"#/v2.0/javascript/api-reference/#appbase-setting-up","title":"SETTING UP"},{"content":"<h3 id=\"appbase-setting-up-credentials\">credentials()</h3><p>Authorize the app credentials using the appname and appsecret identifiers, as they appear in the <a href=\"//appbase.io/developer\">Dev Console</a>.</p><p><strong>Usage</strong></p><p><code>Appbase.credentials(appname, [appsecret , onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p>","link":"#/v2.0/javascript/api-reference/#appbase-setting-up-credentials","title":"credentials()"},{"content":"<h2 id=\"appbase-namespaces\">Namespaces</h2>","link":"#/v2.0/javascript/api-reference/#appbase-namespaces","title":"NAMESPACES"},{"content":"<h3 id=\"appbase-namespaces-ns\">ns()</h3><p>Get the namespace reference with the passed <em>string identifier</em>. It creates a new namespace if one doesn’t already exist, else returns reference to the existing namespace. See <em>Namespace Reference</em> docs for how namespaces work.</p><p><strong>Usage</strong></p><p><code>Appbase.ns(namespace)</code></p><p><strong>Returns</strong></p><p><code>Object</code> <strong>nsref</strong> <em>Namespace Reference</em></p>","link":"#/v2.0/javascript/api-reference/#appbase-namespaces-ns","title":"ns()"},{"content":"<h2 id=\"appbase-fantastic-search\">Fantastic Search</h2>","link":"#/v2.0/javascript/api-reference/#appbase-fantastic-search","title":"FANTASTIC SEARCH"},{"content":"<h3 id=\"appbase-fantastic-search-rawsearch\">rawSearch()</h3><p>Appbase uses ElasticSearch in the backend. To completely understand how it works, please refer to <a href=\"http://docs.appbase.io/docs/elasticsearch.html\">this page</a>.</p>","link":"#/v2.0/javascript/api-reference/#appbase-fantastic-search-rawsearch","title":"rawSearch()"},{"content":"<h2 id=\"appbase-utility\">Utility</h2>","link":"#/v2.0/javascript/api-reference/#appbase-utility","title":"UTILITY"},{"content":"<h3 id=\"appbase-utility-uuid\">uuid()</h3><p>Returns a 32-character uuid.</p><p><strong>Usage</strong></p><p><code>Appbase.uuid()</code></p><p><strong>Returns</strong></p><p><code>String</code> UUID</p>","link":"#/v2.0/javascript/api-reference/#appbase-utility-uuid","title":"uuid()"},{"content":"<h3 id=\"appbase-utility-servertime\">serverTime()</h3><p>Obtain the current time in <em>milliseconds</em> since epoch.</p><p><strong>Usage</strong></p><p><code>Appbase.serverTime(onComplete)</code></p><p><strong>onComplete</strong> <code>Function</code> will be passed with two arguments.</p>","link":"#/v2.0/javascript/api-reference/#appbase-utility-servertime","title":"serverTime()"},{"content":"<h1 id=\"namespace-reference\">Namespace Reference</h1><p>Namespace Reference Object or <code>nsref</code> has methods for creating vertices, searching vertices, and event listeners to the addition and removal of vertices.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference","title":"NAMESPACE REFERENCE"},{"content":"<h2 id=\"namespace-reference-vertices\">Vertices</h2>","link":"#/v2.0/javascript/api-reference/#namespace-reference-vertices","title":"VERTICES"},{"content":"<h3 id=\"namespace-reference-vertices-v\">v()</h3><p>Creates a new vertex or obtains a reference to an existing vertex.</p><p><strong>Usage</strong></p><p><code>nsref.v(path)</code></p><p><strong>Returns</strong></p><p><strong>vref</strong> <code>Object</code> <em>Vertex Reference</em></p><p><code>Note:</code> Use a string identifier if you are creating a new vertex. A new vertex cannot be created recursively, avoid using non-existent paths.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-vertices-v","title":"v()"},{"content":"<h2 id=\"namespace-reference-search\">Search</h2>","link":"#/v2.0/javascript/api-reference/#namespace-reference-search","title":"SEARCH"},{"content":"<h3 id=\"namespace-reference-search-search\">search()</h3><p>Powerful realtime search on vertices inside a namespace, with options to search using one or more data properties. It returns not just matched strings, but all the matching vertices.</p><p><strong>Note:</strong> Search has to be manually enabled on the namesapces using the <a href=\"http://appbase.io/developer\">Developer Dashboard</a>.</p><p><strong>Usage</strong></p><p><code>nsref.search(queryObj, onComplete)</code></p><p><strong>queryObj</strong> <code>Object</code> — A Javascript Object containing the following fields and values</p><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-search-search","title":"search()"},{"content":"<h2 id=\"namespace-reference-retrieving-data\">Retrieving Data</h2>","link":"#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data","title":"RETRIEVING DATA"},{"content":"<h3 id=\"namespace-reference-retrieving-data-on\">on()</h3><p>Retrieve existing vertices, and listen to addition or removal of vertices.</p><p><strong>Usage</strong></p><p><code>nsref.on(eventType , callback [, onComplete])</code></p><p><strong>callback</strong> <code>Function</code> (optional) — is called when with existing vertices, and when ever a new vertex is added. It will be passed two arguments:</p><p><strong>onComplete</strong> <code>Function</code> - Called when all the existing vertices have been retrieved. It will be called only once, with arguments:</p><p><code>Note:</code> <code>vertex_added</code> event listener returns the existing vertices in the namespace when listening for the first time.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data-on","title":"on()"},{"content":"<h3 id=\"namespace-reference-retrieving-data-off\">off()</h3><p>Turn off the listeners on a given namespace reference.</p><p><code>nsref.off([eventType])</code></p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-retrieving-data-off","title":"off()"},{"content":"<h2 id=\"namespace-reference-utility\">Utility</h2>","link":"#/v2.0/javascript/api-reference/#namespace-reference-utility","title":"UTILITY"},{"content":"<h3 id=\"namespace-reference-utility-name\">name()</h3><p>Returns the name of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.name()</code></p><p><strong>Returns</strong></p><p><strong>name</strong> <code>String</code> Name of the <code>nsref</code>.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-utility-name","title":"name()"},{"content":"<h3 id=\"namespace-reference-utility-path\">path()</h3><p>Returns the path of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.path()</code></p><p>The method accepts no arguments, and returns a path of the <code>nsref</code> resource. Since namespaces are top-level objects, the path for a namespace is just the <em>namesapce identifier</em>.</p><p><strong>Returns</strong></p><p><strong>path</strong> <code>String</code> Path of the <code>nsref</code> is usually the namespace identifier.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-utility-path","title":"path()"},{"content":"<h3 id=\"namespace-reference-utility-url\">URL()</h3><p>Appbase URL of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.URL()</code></p><p>The method accepts no arguments, and returns a URL of the <code>nsref</code> resource.</p><p><strong>Returns</strong></p><p><strong>url</strong> <code>String</code> Data URL of the namespace reference. The format of the URL is <code>api.appbase.io/:appname/:version/namespace</code>.</p>","link":"#/v2.0/javascript/api-reference/#namespace-reference-utility-url","title":"URL()"},{"content":"<h1 id=\"vertex-reference\">Vertex Reference</h1><p>Vertex Reference Object or <code>vref</code> has the methods for setting data, creating links to other vertices, and different listeners to notify about data changes, link changes, etc.</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference","title":"VERTEX REFERENCE"},{"content":"<h2 id=\"vertex-reference-storing-data\">Storing Data</h2>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data","title":"STORING DATA"},{"content":"<h3 id=\"vertex-reference-storing-data-setdata\">setData()</h3><p>Set one or more data properties on this vertex reference.</p><p><strong>Usage</strong></p><p><code>vref.setData(dataObject [, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-setdata","title":"setData()"},{"content":"<h3 id=\"vertex-reference-storing-data-commitdata\">commitData()</h3><p>Atomically modify properties of the vertex. Unlike setData(), which just overwrites the properties regardless of their previous values, commitData() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.</p><p><strong>Usage</strong></p><p><code>vref.commitData(applyFunction [, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p><p><code>applyFunction</code> is called once and the new data is sent to the server for write. If another client writes to the vertex before your new value is successfully written, the <code>applyFunction</code> will be called again with the new current value, and the write will be retried.</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-commitdata","title":"commitData()"},{"content":"<h3 id=\"vertex-reference-storing-data-removedata\">removeData()</h3><p>Removes one or more data properties from this vertex reference.</p><p><strong>Usage</strong></p><p><code>vref.removeData(propertyName [, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-removedata","title":"removeData()"},{"content":"<h3 id=\"vertex-reference-storing-data-setedge\">setEdge()</h3><p>Create a link to another vertex. You can optionally set priority to links.</p><p><strong>Usage</strong></p><p><code>vref.setEdge(edgeName [, outVertex, priority, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed three arguments:</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-setedge","title":"setEdge()"},{"content":"<h3 id=\"vertex-reference-storing-data-removeedge\">removeEdge()</h3><p>Remove a link from the current vertex.</p><p><strong>Usage</strong></p><p><code>vref.removeEdge(edgeName [, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-removeedge","title":"removeEdge()"},{"content":"<h3 id=\"vertex-reference-storing-data-destroy\">destroy()</h3><p>Destroys a vertex from Appbase. All edges pointing to this vertex are also removed. This causes <strong>vertex_removed</strong> to be fired on the namespace where this vertex belongs.</p><p><strong>Usage</strong></p><p><code>vref.destroy([, onComplete])</code></p><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed the argument:</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-storing-data-destroy","title":"destroy()"},{"content":"<h2 id=\"vertex-reference-retrieving-data\">Retrieving Data</h2>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data","title":"RETRIEVING DATA"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onproperties\">on(‘properties’)</h3><p>Fetch current properties, and listen to changes in the properties of a vertex.</p><p><strong>Usage</strong></p><p><code>vref.on('properties', callback)</code></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onproperties","title":"on(‘properties’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onceproperties\">once(‘properties’)</h3><p>As the name suggests, it works exactly like <code>on(\"properties\")</code> except that it will be fired only once. When you want to fetch only the current properties and don’t want to listen to changes, you can use <code>once()</code>.</p><p><strong>Usage</strong></p><p><code>vref.once('properties', callback)</code></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onceproperties","title":"once(‘properties’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_added\">on(‘edge_added’)</h3><p>Get existing edges added at a location, and listen to new ones.</p><p><strong>Usage</strong></p><p><code>vref.on('edge_added' [, filters ],  callback [, onComplete])</code></p><p>With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them.</p><p>When more than one filter is provided, they work as logical <code>AND</code> and only the edges matchihg all filters will be fetched. This is what each filter means:</p><p>Notice that:\n - Filters are a way to fetch existing edges, thus they work only with <em>edge_added</em> event\n - Edges are always returned ordered according to their priorities\n - When <em>endAt</em> &lt; <em>startAt</em>, edges are returned in reverse order\n - You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime\n    - This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code>\n    - <em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_added","title":"on(‘edge_added’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_removed\">on(‘edge_removed’)</h3><p>Listen to removal of edges. </p><p><strong>Usage</strong></p><p><code>vref.on('edge_removed', callback)</code></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_removed","title":"on(‘edge_removed’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_changed\">on(‘edge_changed’)</h3><p>When ever an edge is replaced, i.e. <code>setEdge()</code> is called with an existing edge name, this event is fired.</p><p><strong>Usage</strong></p><p><code>vref.on('edge_changed', callback)</code></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-retrieving-data-onedge_changed","title":"on(‘edge_changed’)"},{"content":"<h2 id=\"vertex-reference-utility\">Utility</h2>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility","title":"UTILITY"},{"content":"<h3 id=\"vertex-reference-utility-outvertex\">outVertex()</h3><p>Reference to the corresponding <code>outVertex</code> with the given name.</p><p><strong>Usage</strong></p><p><code>vref.outVertex(edgeName)</code></p><p><strong>Returns</strong></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility-outvertex","title":"outVertex()"},{"content":"<h3 id=\"vertex-reference-utility-invertex\">inVertex()</h3><p>Reference to the corresponding <code>inVertex</code> from the current vertex.</p><p><strong>Usage</strong></p><p><code>vref.inVertex()</code></p><p><code>Note:</code> Since vertices are accessed via a path, there is only one <code>inVertex</code> for each vertex. Calling this method on the root vertex such as ``Appbase.ns(“Domains”).v(“www.appbase.io”) will thrown an error.</p><p><strong>Returns</strong></p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility-invertex","title":"inVertex()"},{"content":"<h3 id=\"vertex-reference-utility-path\">path()</h3><p>Returns the path of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.path()</code></p><p>The method accepts no arguments, and returns a path of the <code>vref</code> resource.</p><p><strong>Returns</strong></p><p><strong>path</strong> <code>String</code> Path of the <code>vref</code> is a UNIX style path of the format namespace/:vertex1/:vertex2/vref.</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility-path","title":"path()"},{"content":"<h3 id=\"vertex-reference-utility-name\">name()</h3><p>Returns the name of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.name()</code></p><p><strong>Returns</strong></p><p><strong>name</strong> <code>String</code> Name of the <code>vref</code>.</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility-name","title":"name()"},{"content":"<h3 id=\"vertex-reference-utility-url\">URL()</h3><p>Appbase URL of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.URL()</code></p><p>The method accepts no arguments, and returns a URL of the <code>vref</code> resource.</p><p><strong>Returns</strong></p><p><strong>url</strong> <code>String</code> Data URL of the namespace reference. The format of the URL is <code>api.appbase.io/:appname/:version/ns/:vertex1/:vertex2</code>.</p>","link":"#/v2.0/javascript/api-reference/#vertex-reference-utility-url","title":"URL()"},{"content":"<h1 id=\"data-snapshots\">Data Snapshots</h1><p>Data snapshots are immutable copies of the data stored at <code>Appbase References</code><em>. There are two kinds of snapshots: <code>Property Snapshot</code></em> and <code>Edge Snapshot</code>_, fired when listening to on(‘properties’) or one of the edge listeners.</p>","link":"#/v2.0/javascript/api-reference/#data-snapshots","title":"DATA SNAPSHOTS"},{"content":"<h3 id=\"data-snapshots-property-snapshot\">Property Snapshot</h3><p>It holds the property data of a vertex in Appbase. It has the following methods to obtain the changes in the Appbase Reference.</p>","link":"#/v2.0/javascript/api-reference/#data-snapshots-property-snapshot","title":"Property Snapshot"},{"content":"<h3 id=\"data-snapshots-edge-snapshot\">Edge Snapshot</h3><p>It holds the edge data. It has the following methods to obtain the edge related changes in the Appbase Reference.</p>","link":"#/v2.0/javascript/api-reference/#data-snapshots-edge-snapshot","title":"Edge Snapshot"}]